**Байты** (bytes) → **Символы** (characters) → **Лексемы** → **Токены** (tokens) → **Узлы** (nodes) → **Объектная модель** (object model)

*Алгоритм обработки HTML-файла*:
1) **Загрузка файла**. Браузер загружает файл (обычно из сети или локальной файловой системы, т.е. с диска), закодированный какой-то кодировкой. В компьютерной памяти все файлы представляются байтами, поэтому при загрузке файла браузер получает поток байтов.
```css![DNS](./assets/DNS.png)
EF BB BF EF B9 A4 68 74 6D 6C EF B9 A5
```
1) **Распознавание кодировки**. Сначала браузер пытается распознать кодировку. Он считывает первые три байта из потока в буфер и проверяет, являются ли они символом маркера последовательности байтов (Byte Order Mark, `U+FEFF`), который указывает кодировку. Если да, то оставшиеся символы расшифровываются с учётом этой кодировки, если нет, то браузер пытается распознать кодировку самостоятельно, в случае неудачи далее используется кодировка UTF-8.
```css
0xEF 0xB9 0xA4 → U+FEFF → маркер кодировки UTF-8
```
1) **Преобразование байтов в символы (decoding)**. Браузер расшифровывает (decode) поток байтов (stream of bytes) в символы, опираясь на заданную кодировку (encoding). [Подробнее об алгоритме декодирования можно прочитать здесь](./Encoding.md).
```html
0xEF 0xB9 0xA4 → U+FE64 → "<"
0x68 → U+0068 → "h"
0x74 → U+0074 → "t"
0x6D → U+006D → "m"
0x6C → U+006C → "l"
0xEF 0xB9 0xA5 → U+FE65 → ">"

<html>
```
1) **Лексический анализ (lexing, tokenization)**. Браузер конвертирует последовательности символов в отдельные распознанные группы — **лексемы**, каждая из которых имеет определённый смысл. Затем лексемы преобразовываются в объекты — **токены**, имеющие определённые свойства и правила.  

Пример *разбиения HTML на лексемы*: `<div class="box"></div>`.  
`<` - начало тега, `div` - название тега, `class` - название атрибута, `=` - символ, объединяющий атрибут и его значение, `"` - начало значения атрибута, `box` - значение атрибута, `"` - конец значения атрибута, `>` - конец тега, `</` - начало закрывающего тега, `div` - название тега, `>` - конец тега.  

1) **Построение объектной модели**. На основании информации токенов и их последовательности выясняется, из каких элементов состоит HTML и как они расположены по отношению друг к другу. Первое позволяет представить html-элементы в виде объектов. Второе — в виде дочерних и родительских элементов одного дерева. Поскольку в качестве узлов, вершин (nodes) дерева берутся объекты, полученная модель называется **объектной моделью**.  

Полученную модель называют **объектной моделью документа** (Document Object Model, DOM).  

Этот *алгоритм браузер* проделывает *каждый раз*, когда нужно *обработать HTML*.

Теперь *браузер загружает подключенные* к HTML-документу *ресурсы* (делая к ним запросы): картинки, видео, иконки, шрифты, а также *CSS*.
```html
<link rel="stylesheet" type="text/css" href="/styles.css"/>
```

Любой CSS, присутствующий в документе (загруженный файлом или встроенный в документ при помощи `<style>`, `style=""`), браузер обрабатывает по тому же алгоритму, что и HTML, однако до построения объектной модели происходит ещё два важных действия:
* каскад
* обработка значений.


Получившееся в результате работы алгоритма представление в виде дерева называется **объектной моделью CSS** (CSS Object Model, CSSOM).

Пример *разбиения CSS на лексемы* : `.box { width: 40px; }`.  
`.` - начало селектора по классу, `box` - название класса, `{` - начало блока объявлений, `width` - свойство, `:` - символ, объединяющий свойство с его значением, `40px` - значение свойства, `;` - конец объявления, `}` - конец блока объявлений.

В CSS многие стили применяются не только к самому элементу, но и к его потомкам.  
Это называется наследованием: потомки наследуют свойства предка.  
Именно поэтому CSS имеет древовидную структуру.
