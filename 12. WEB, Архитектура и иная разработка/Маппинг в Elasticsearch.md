[[Маппинг]]


*Маппинги задаются* при *создании индекса* в *поле* `mappings`. Они *содержат свойства документов* и *типы* их *значений*.

Поскольку маппинги могут быть разными для разных типов `type` индекса, они привязываются не к самому индексу, а к самим типам (например, к типу по умолчанию `_doc`). Поэтому при создании маппинга нужно всегда указывать тип.

Если `mappings` не задаётся при создании индекса, то Elasticsearch создаёт его автоматически в режиме реального времени на основании данных индексируемых документов.

## Создание индекса

Для создания индекса используется PUT-запрос с его названием.
```http
PUT <ELASTICSEARCH_URL>/index_name
```
```js
/* response body */
{
  "acknowledged": true,
  "shards_acknowledged": true,
  "index": "index_name"
}
```

## Простые [[Типы данных|типы данных]]
* **Строковые** (string): `text`, `keyword`.
* **Числовые** (Numberic): `long`, `integer`, `short`, `byte`, `double`, `float`, `half_float`, `scaled_float`.
* **Логический** (Boolean): `boolean`.
* **Дата** (Date): `date`.
* **Бинарный** (Binary): `binary`.
* **Диапазон** (Range): `integer_range`, `float_range`, `long_range`, `double_range`, `date_range`.

### Тип данных text

Строковый тип `text` используется для индексирования **полнотекстовых значений** (full-text values). Примерами полнотекстовых значений являются поля: название, сообщение, описание.

*Полнотекстовые значения* **анализируются**, то есть обрабатываются перед *индексированием*. 

Каждое *полнотекстовое поле проходит перед индексированием* через **анализатор** (analyzer), который *конвертирует строку* в *список отдельных термов* (list of individual terms), затем этот *список индексируется*, а *поле* называют **проанализированным** (analyzed). 

**Анализирование** (analysis) позволяет *Elasticsearch* *искать отдельные слова* в *каждом полнотекстовом поле*.

*Поля текстового типа* *не используются* для *сортировки*, обычно *не используются* для *агрегаций*.

Задание типа `text`.
```http
PUT <ELASTICSEARCH_URL>/index_name
Content-Type: application/json

{
  "mappings": {
    "_doc": {
      "properties": {
        "description": {
          "type":  "text"
        }
      }
    }
  }
}
```

### Тип данных keyword

*Строковый тип* `keyword` (ключевое слово) используется для *индексирования* таких *значений*, как: `ID`, `email`, `hostname`, `status code`, `tag` и прочих. Эти *значения используются* для *фильтрации*, *сортировки* и *агрегации*. 

Поля типа `keyword` *не анализируются*. Они *ищутся только по точному значению, совпадению* (exact value). Например, нельзя найти `tom@gmail.com` по слову `tom` или `gmail`.

Задание типа `keyword`.
```http
PUT <ELASTICSEARCH_URL>/index_name
Content-Type: application/json

{
  "mappings": {
    "_doc": {
      "properties": {
        "email": {
          "type":  "keyword"
        }
      }
    }
  }
}
```

## Составные типы данных
* **Объект** (Object): `object`. Для JSON-объекта.
* **Вложенный** (Nested): `nested`. Для массива JSON-объектов.

### Объект

**Объект** (Object) предназначен для хранения JSON-объектов.

JSON-объекты могут содержать в себе другие JSON-объекты, то есть они имеют иерархичную структуру.

Например, для индексируемого объекта ниже
```js
{
  "name": "Manfredi",
  "age": 27,
  "settings": {
    "theme": "dark"
  }
}
```
может быть задан следующий маппинг.
```http
{
  "mappings": {
    "_doc": {
      "properties": {
        "email": {
          "name":  { "type": "text"  },
          "age": { "type": "integer"  },
          "settings": {
            "properties": {
              "theme": { "type": "keyword"  }
            }
          }
        }
      }
    }
  }
}
```
Elasticsearch распознаёт, что поле `settings` является объектом, благодаря свойству `properties`. Вложенные свойства `properties` отображают иерархию JSON-объектов.

### Массив

**Массив** (Array) в Elasticsearch не существует как отдельная сущность, поскольку любое поле может иметь одно или несколько значений по умолчанию. Тем не менее, все эти значения должны быть одного типа.

* Массив строк: `["1", "two"]`.
* Массив чисел: `[1, 7]`.
* Массив объектов `[{ "name": "John", "experience": 5 }, { "name": "Sam", "experience": 3 }]`.

В массиве объектов нельзя выделить конкретный объект. При такой необходимости нужно использовать тип `nested`.

Массивы смешанных типов не поддерживаются: `[1, "two"]`.

Пустой массив интерпретируется как отсутствующее значение (поле без значений).

Вставка объекта с массивом `tags`.
```http
PUT <ELASTICSEARCH_URL>/index_name/_doc/1
Content-Type: application/json

{
  "message": "The problem with useEffect",
  "tags":  [ "js", "react", "react-hooks" ]
}
```

### Особенность массива объектов

В массиве объектов Elasticsearch не рассматривает объекты как независимые сущности, поэтому Elasticsearch просто разбивает их на список полей и значений.

Например, вставка следующего массива объектов
```http
PUT <ELASTICSEARCH_URL>/index_name/_doc/1
Content-Type: application/json

{
  "user" : [ 
    {
      "firstName" : "Max",
      "lastName" :  "Starling"
    },
    {
      "firstName" : "Richard",
      "lastName" :  "Stone"
    }
  ]
}
```
будет преобразована в два поля с несколькими значениями.
```js
{
  "user.firstName" : [ "Max", "Richard" ],
  "user.lastName" :  [ "Starling", "Stone" ]
}
```
Связь между полями `firstName` и `lastName` теряется и они уже больше не являются одним объектом.

Поэтому при поиске следующий запрос не выдаст совпадений.
```js
[
  { "match": { "user.firstName": "Max" }},
  { "match": { "user.lastName": "Starling" }}
]
```

### Сравнение массива объектов и вложенного типа

**Вложенный тип данных** (Nested datatype) — специальный подтип объекта (`object`), который позволяет индексировать массив JSON-объектов таким образом, чтобы объекты можно было получать отдельно друг от друга.


## Специализированные типы данных
* **IP**: `ip`. Для IPv4 и IPv6 адресов.
* **Completion** (Completion datatype): `completion`. Для автозаполнения предложений.
* **Join**: `join`. Для создания отношений между документами одного индекса.
* **Search-as-you-type**: `search_as_you_type`. Для поиска по мере ввода.

## Мультиполя

Elasticserach предоставляет возможность *хранить одно и то же полt несколькими способами* для *разных целей*. Такое *поле* называется **мультиполем** (multi-field).

Например, *текстовое поле* может быть *одновременно* представлено *типом* `text` для *полтотекстового поиска* и типом `keyword` *для сортировки* и *агрегаций*.

Для определения мультиролей используется свойство `fields`, значением которого выступает объект. Ключом этого объекта является название мультиполя, а в значении описывается тип.

Например, создадим текстовое поле `position`, которое может быть использовано как ключевое слово.
```http
PUT <ELASTICSEARCH_URL>/index_name
Content-Type: application/json

{
  "mappings": {
    "properties": {
      "position": {
        "type": "text",
        "fields": {
          "keyword": { 
            "type":  "keyword"
          }
        }
      }
    }
  }
}
```
Теперь, при необходимости использования `position` как ключевого слова, необходимо писать `position.keyword`, иначе оно будет работать как текстовое значение.

### Получение текущих маппингов

Текущие *маппинги индекса* можно *получить* по *GET-запросу* `_mappings`.
```http
GET <ELASTICSEARCH_URL>/index_name/_mappings
```
