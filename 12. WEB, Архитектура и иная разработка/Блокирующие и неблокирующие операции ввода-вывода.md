## Блокирующие и неблокирующие операции ввода-вывода

**Блокировка** (англ. `blocking`) — ситуация, при которой *следующий блок кода не может быть запущен*, поскольку *основной поток занят выполнением* (ожиданием выполнения) *предыдущего блока кода*.

Операции, которые приводят к *блокировке основного потока* называют **блокирующими операциями ввода-выввода** (англ. `blocking I/O`). Обычно к ним относят *трудоёмкие синхронные операции ввода-вывода*.

<!-- Например, следующий код NodeJS работает с файлами синхронно.
```js
const fs = require('fs');

fs.writeFileSync('./input.txt', 'Hello!', 'utf8');
const data = fs.readFileSync('./input.txt', 'utf8');
console.log(data);
fs.unlinkSync('./input.txt');
```

*Логирование* также является *блокирующей операцией ввода-вывода*, поскольку *затрагивает системный поток ввода-вывода*, но такая операция не занимает слишком много времени, а асинхронный вариант было бы совсем не удобно использовать.
```js
var a = 1;
console.log(a); // 1 (асинхронный вариант мог бы вывести здесь 2).
a += 1;
```

<!-- В браузере основной поток может быть заблокирован функцией `alert` до тех пор, пока пользователь не закроет всплывшее окно. -->
<!-- 
Операции ввода-вывода, которые не блокируют основной поток, называют **неблокирующими операциями ввода-вывода** (Non-blocking I/O). К ним обычно относят *асинхронные операции ввода-вывода*.

JavaScript-код выполняется довольно быстро и считается неблокирующим. Тем не менее, такая блокировка возможно, если запущен код, который выполняется бесконечно (бесконечный цикл, бесконечная рекурсия) или очень долго (цикл до 1000000). 

Например, код ниже никогда не завершится. 
```js
while (true) { /* ... */ }
```

JavaScript в браузере и NodeJS на сервере ориентированны на события. На клиенте важно быстро реагировать на действия пользователя, на сервере — отвечать на запросы клиента. Нельзя терять время на ожидание завершения операций, которые выполняются вне основного скрипта. Поэтому очень важно стремиться использовать асинхронные операции: они не блокируют основной поток, позволяя обрабатывать другие события.

Например, есть запрос, который обрабатывается 100 миллисекунд, из которых 80 уходят на выполнение операций, которые могут блокировать основной поток. В синхронном режиме эти 80 миллисекунд сервер простаивает, в асинхронном он может потратить это время на обработку других запросов. 

Тем не менее, просто сделать все функции асинхронными не получится, некоторые операции всё же должны выполняться последовательно. Если заменить синхронность на асинхронность в примере выше, то удаление файла может начаться раньше, чем закончится чтение, а вывод результата — раньше его получения. 
```js
writeFile('./input.txt', 'Hello!', 'utf8');
const data = readFile('./input.txt', 'utf8');
console.log(data);
unlink('./input.txt');
```
Тут требуется особый подход: использование *функции обратного вызова*. -->
