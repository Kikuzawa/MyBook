# Цикл событий NodeJS

**Цикл событий** (Event Loop) — механизм, позволяющий *NodeJS выполнять неблокирующие операции ввода-вывода*. Когда NodeJS встречает в запущенном скрипте асинхронную операцию ввода-вывода, он выгружает её в ядро системы и продолжает выполнение других операций в основном потоке. Когда асинхронная операция заканчивает своё выполнение, генерируется событие о том, что её колбэк может быть помещён в очередь на исполнение. 

Поскольку большинство ядер многопоточны, они могут обрабатывать несколько задач одновременно в фоновом режиме.

Цикл событий выполняется в том же потоке, что и основной скрипт, но запускается только после завершения работы скрипта. Это позволяет циклу событий не блокировать основной поток при запуске проекта и даёт преимущество перед похожими технологиями в других языках.

Цикл событий не может работать, пока стек вызовов не пуст. Он ждёт, пока освободится стек вызовов и, если в очереди есть готовые к исполнению колбеки, берёт первый из них и помещает его в стек. Когда стек снова освобождается, в него помещается следующий колбек и так далее.

Как в браузере, так и в NodeJS цикл событий скрыт от программиста, является частью внутренней реализацией.

<!-- Если в скрипте встречается какая-то асинхронная операция, её выполнение выносится из основного потока, а её колбэк выносится в цикл событий. Это позволяет продолжить выполнение скрипта и больше не возвращаться в это же место. Когда скрипт завершает работу, начинается работа цикла событий (если операции заканчивают своё выполнение, то в основном потоке запускаются их колбэки). Когда колбэки заканчиваются в цикле событий, NodeJS усыпляет его до дальнейших указаний.
-->

*Один полный обход* (итерация) *цикла событий* называется **тиком** (tick).

## Фазы цикла событий

Во время выполнения основного скрипта вызываются асинхронные операции (таймеры, операции ввода-вывода), происходит подписка на события. Каждая такая операция имеет колбэк, который по завершению операции в зависимости от её типа помещается в характерную очередь. Каждая очередь представляет собой определённую **фазу** (phase) цикла событий.

Цикл событий не совсем является циклом, он состоит из набора фаз, которые повторяются по кругу.

*Основные фазы тика цикла событий*
* **Таймеры** (Timers) — *колбэки истёкших* `setTimeout` и `setInterval`.
* **Ожидающие колбэки** (Pending callbacks) — *колбэки системных операций* (например, ошибки TCP).
* **Опрос** (Poll) — *ожадание новых колбэков* (таймеров, ожидающих колбэков) и их выполнение. Здесь выполняется большинство *колбэков завершённых операции ввода-вывода* (I/O).
* **Проверка** (Check) — *колбэки* `setImmediate`.
* **Закрывающие колбэки** (Close callbacks) — *колбэки закрывающихся соединений*.

Все фазы выполняются последовательно.

Когда цикл событий останавливается на определённой фазе, он выполняет все её колбэки до тех пор, пока они не закончатся или не будет достигнут лимит их выполнения. Затем цикл событий переходи к следующей фазе.

Все операции, относящиеся к основным фазам, можно назвать **задачами** (Tasks).

Любая операция ввода-вывода может планировать другие операции ввода-вывода и события.

Перед каждой фазой последовательно выполняются две промежуточные (intermediate) фазы:
* **Очередь для nextTick** (nextTick Queue). Колбэки `process.nextTick`.
* **Очередь микрозадач** (Microtasks Queue). Колбэки разрешённых (resolved) `Promise`.

Фактически, все операции, относящиеся к промежуточным фазам, можно назвать **микрозадачами** (microtasks). Они не совсем являются частью цикла событий, предоставляемого библиотекой `libuv`, но являются частью NodeJS.

Переход к следующей фазе не происходит, пока имеются невыполненные микрозадачи.

NodeJS следит за выполнением незаконченных асинхронных операций и прогоняет цикл событий до тех пор, пока они все не завершат своё выполнение. Когда все операции завершили своё выполнение, NodeJS усыпляет цикл событий до наступления новых событий.

## Пример работы цикла событий

* Программист запускает приложение, точкой входа в которое является скрипт `app.js`. В этот момент создаётся поток (thread), в котором будет выполняться приложение и инициализируется цикл событий (event loop).
```
node app.js
```



<!--

Код ниже отработает синхронно, последовательно.
```js
console.log('before');
console.log('after');
// выведет "before", "after"
```
Следующие два примера отработают асинхронно, непоследовательно.
```js
Promise.resolve('before').then(console.log);
console.log('after');
// выведет "after", "before"
```
```js
setTimeout(() => console.log('before'), 0);
Promise.resolve('after').then(console.log);
// выведет "after", "before"
```
Чтобы симулировать синхронное поведение (выполнить инструкции с логированием в правильном порядке), можно написать следующее.
```js
const after = () => console.log('after');

Promise.resolve('before')
  .then(console.log)
  .then(after);
// выведет "before", "after"

setTimeout((after) => {
  console.log('before');
  after();
}, 0, after);
// выведет "before", "after"
```
-->
