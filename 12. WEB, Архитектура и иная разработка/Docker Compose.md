## Композиция контейнеров

Чаще всего приложения можно разделить на несколько контейнеров, которые зависят друг от друга. Понятно, что, чтобы приложение заработало, эти контейнеры нужно запускать вместе, причём в определённом порядке. Такой запуск называется **композицией контейнеров**.

**Docker Compose** — инструмент, позволяющий *составлять композицию контейнеров* (запускать приложения, состоящие из нескольких контейнеров).

Docker Compose использует файлы формала YAML (`.yml`).

## Сервисы

Docker Compose файл состоит из **сервисов** (services). Сервис содержит в себе все данные, необходимые для запуска конкретного контейнера (с предварительным созданием образа для него при необходимости). 

Есть два способа запустить сервис.
* Можно указать готовый образ в поле `image` (можно скачать его с Docker Hub или создать самому).
```yaml
# docker-compose.yml
version: '3.7'
services:
  foo:
    image: image_name
```
* Можно настроить этап построения в поле `build`, указав там путь к Dockerfile, по которому должен быть построен образ.
```yaml
# docker-compose.yml
version: '3.7'
services:
  bar:
    build:
      context: ./bar
      dockerfile: Dockerfile
```

## Порядок запуска сервисов

Docker Compose запускает и останавливает контейнеры в порядке их зависимостей. 

Если зависимости между контейнерами не указаны, то контейнеры запускаются последовательно.

Настроить зависимость можно при помощи поля `depends_on`.

В примере ниже запуск сервиса `server` произойдёт раньше, чем запуск `client`.
```bash
docker-compose up
```
```yml
# docker-compose.yml
version: '3.7'
services:
  client:
    image: image_name
    depends_on: server
  server:
    image: another_image_name
```
В случае остановки происходит обратная ситуация: `client` останавливается раньше, чем `server`.
```bash
docker-compose stop
```

Здесь важно отметить, что Docker Compose дожидается лишь окончания запуска контейнера, но не полной готовности того, что лежит внутри него. К примеру, база данных в контейнере может быть не готова к соединениям в тот момент, когда контейнер только запустился. В таких случаях нужно конфигурировать приложение таким образом, чтобы подключение к базе данных повторялось через некоторое время после каждой неудачной попытки.

<!-- Когда запускается Docker Compose, он сначала обрабатывает все `build` -->

## Порты

Можно указать порты на хост-машине и внутри контейнера, по которым будет доступно приложение.

Сервис `foo` будет доступен на порте 3000 внутри контейнера.
```yaml
# docker-compose.yml
version: '3.7'
services:
  foo:
    image: image_name
    ports:
     - "3000"
```
Сервис `bar` будет доступен на порте 4000 внутри контейнера и на порте 3001 на хост-машине.
```yaml
# docker-compose.yml
version: '3.7'
services:
  bar:
    image: image_name
    ports:
     - "3000:4000"
```
Конфигурация сервиса `baz` эквивалетна конфигурации сервиса `foo`.
```yaml
# docker-compose.yml
version: '3.7'
services:
  baz:
    image: image_name
    ports:
     - target: 4000 # порт, выставленный внутри контейнера
       published: 3000 # опубликованный порт (на хост-машине)
```


## Пример композиции контейнеров трёхуровнего приложения

*Трёхуровневое* (3-tier) *приложение* состоит из клиента, сервера и базы данных. Для каждого уровня необходим отдельный контейнер, а поскольку они связаны друг с другом, создаётся их композиция.

Первым подключается база данных (сервис `db`), поскольку её может использовать сервер. Вторым подключается сервер (сервис `server`), поскольку его может использовать клиент. Последним подключается клиент (сервис `client`).

В docker-compose может указываться уже собранный образ (builded image) вместе с командой, которая должна быть запущена в контейнере; или `Dockerfile`, по котому образ будет создаваться.
```yaml
# docker-compose.yml
version: '3.7'
services:
  db:
    command: mongod
    image: mongo:3.6.3
    ports:
      - "27017:27017"
  server:
    build:
      context: "./server"
      dockerfile: Dockerfile
    ports:
      - "4001:4001"
  client:
    build:
      context: "./client"
      dockerfile: Dockerfile
    ports:
      - "4000:4000"
```

## Переменные ENVIRONMENT и ARGS

**Перееменные окружения ENVIRONMENT** передаются в уже запущенные контейнеры. 
```yaml
# docker-compose.yml
client:
  environment:
    - NODE_ENV: production
    - SERVER_URL: xxx
```

<!-- *Docker Compose* поддерживает объявление значений по умолчанию для переменных окружения в `.env` файле. -->

**Переменные ARGS** доступны во время построения образа (build image).

```yaml
# docker-compose.yml
client:
  build:
    args:
      - port: 3000
      - env: production
```

## Передача и использование аргументов в Docker Compose
* Передача любых аргументов осуществляется при запуске Docker Compose в формате `argument=value`.
```cmd
CLIENT_PORT=3000 ENV=production docker-compose up --build
```
* Переданные аргументы доступны для использования в YAML-файле в формате`${argument}`. Есть возможность задать значение по умолчанию: `${argument:-defaultValue}`. Без некоторых значений по умолчанию (например, для портов) может возникать ошибка приведения типов.
```yml
# docker-compose.yml
version: '3.7'
services: 
  client:
    build:
      context: "./client"
      dockerfile: Dockerfile
      args:
        port: ${CLIENT_PORT}
        env: ${ENV}
    environment:
      NODE_ENV: ${ENV}
    ports:
      - "${CLIENT_PORT:-3000}:${CLIENT_PORT:-3000}" # по умолчанию 3000:3000
```

## Проверка конфигурации
Можно проверить правильность настройки, а также посмотреть все установленные переменные при помощи следующей команды.
```cmd
docker-compose config
```
