**Стек вызовов** (Call Stack, Stack) — вспомогательная структура данных в виде LIFO-очереди (Last In First Out), хранящая информацию о том, в каком месте в коде выполняется скипт в данный момент. С помощью стека вызовов можно узнать, какая функция выполняется в данный момент и в пределах какой функции она вызвана.

Поскольку JavaScript однопоточен, в нём имеется лишь один стек вызовов.

Если стек вызовов не пуст, это означает, что основной поток занят выполнением JavaScript-кода.

В стек вызовов помещается следующая информация
* Адрес места (строка и столбец), откуда функция была вызвана. Это позволяет продолжить с места вызова функции после её выполнения.
* Параметры и локальные переменные функции. Таким образом во вложенных функциях переменные доступны из замыкания.

Когда создаются локальные переменные с примитивными значениями и их функция удаляется из стека, они также удаляются из памяти.

Когда создаются локальные переменные с объектам, значения объектов созданяются в кучу (heap), а в переменной сохраняется лишь указатель, ссылка на них, по которой значение можно получить  или изменить. Когда функция, в которой был создан объект, удаляется из стека, объект остаётся в памяти до тех пор, пока его не очистит сборщик мусора (garbage collector).

Стек вызовов является внутренней реализацией V8 и не доступен для JavaScript-разработчика.

Частично стек вызовов можно явно увидеть, когда в приложении возникает ошибка.
```js
const foo = () => {
  throw new Error('something wrong');
};

const bar = () => foo();

bar();
/*
Uncaught Error: something wrong
    at foo (<anonymous>:2:9)
    at bar (<anonymous>:5:19)
    at <anonymous>:7:1
*/
```
У стека вызовов есть максимально допустимая глубина (~10000). Если она достигается (например, посредством бесконечной рекурсии), выбрасывается ошибка о переполнении стека (`stack overflow`).
```js
const foo = () => foo();
foo();
/*
Uncaught RangeError: Maximum call stack size exceeded
    at foo (<anonymous>:1:13)
    at foo (<anonymous>:1:19)
    at foo (<anonymous>:1:19)
    at foo (<anonymous>:1:19)
*/
```

## Пример работы стека вызовов

Пусть имеется следующий скрипт.
```js
/* main.js */

const bar = () => console.log('bar');
const baz = () => console.log('baz');

const foo = () => {
  console.log('foo');
  bar();
  baz();
};

foo();
```
Когда начинает выполняться скрипт, он помещается в стек вызовов (скрипт по сути является одной большой функцией).
```js
/* Call Stack */
- main()
```
Каждая вызванная в скрипте функция добавляется в стэк.
```js
/* Call Stack */
- foo()
- main()
```
Если внутри неё вызываются другая функция, то она помещается в стек поверх предыдущей.
```js
/* Call Stack */
- bar()
- foo()
- main()
```
Когда функция завершает своё выполнение, она удаляется из стека.
```js
/* Call Stack */
- foo()
- main()
```
Далее аналогично, пока скрипт не завершит свою работу и стек не опустеет.
```js
/* Call Stack */
- baz()
- foo()
- main()
```
```js
/* Call Stack */
- foo()
- main()
```
```js
/* Call Stack */
- main()
```
```js
/* Call Stack */
```
