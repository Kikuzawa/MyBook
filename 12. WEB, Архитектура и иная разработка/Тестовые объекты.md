# Тестовые объекты
- [Пустышка](#пустышка)
- [Заглушка](#заглушка)
- [Макет](#макет)

Для достижения изолированности какого-то блока тестируемого кода внешние зависимости при его тестировании заменяются **тестовыми объектами**.

<!-- Тестовые объекты увеличивают переиспользуемость тестов и улучшают их поддержку. -->

## Пустышка

**Пустышка (Dummy)** — простейший тестовый объект, реализующий интерфейс, минимально совместимый с интерфейсом реального объекта. 

Код Dummy не содержит никакой логики.  

Dummy используется в тех случаях, когда обращение к реальному объекту в данном тесте не имеет значения или отсутствует.

Например, нам в контексте теста не нужна проверка авторизации, поэтому мы заменяем реальную функцию `checkAuth()` на тестовую, которая всегда возвращает истиное значение.
```js
const checkAuth = () => true;

checkAuth(); // true
```
В реальности же функция `checkAuth` могла иметь следующий интерфейс `(token: string) => boolean`.

## Заглушка

**Заглушка (Stub)** — тестовый объект, частично реализующий логику реального объекта (валидные данные на входе - валидные данные на выходе).

Stub обычно содержит тривиальную логику, имитирующую работу нескольких методов реального объекта.

<!-- функция или метод класса, которая подменяет реализацию оригинальной функции и не выполняет никакого осмысленного действия, возвращает пустой результат или тестовые данные. -->

Например, имитируем создание пользователя в базе данных: принимаем данные пользователя и сразу же возвращаем полученные данные вместе с сгенерированным id (должен был сгенерироваться в бд).
```js
const generateId = () => parseInt(Math.random() * 1000);

const createUser = data => Promise.resolve({
  ...data,
  _id: generateId(),
});
```

Перепишем пример для Dummy так, чтобы он смог стать Stub (принимает валидные данные и отдаёт тоже).
```js
const checkAuth = token => !!token;

checkAuth('qq'); // true
checkAuth(''); // false
```

## Макет 

**Макет (Mockup)** — модуль или класс, представляющий собой конкретную фиктивную (dummy) реализацию определенного интерфейса. 

Макет, как правило, предназначен для подмены оригинального объекта системы исключительно для тестирования взаимодействия и изолированности тестируемого компонента.

Методы макета чаще всего из себя представляют заглушки.

### Пример макета

Пусть имеется интерфейс, описывающий методы работы с базой данных.
```ts
import { ICreateUser } from '/* ... */';
import { IUser } from '/* ... */';

interface IUserRepository {
  createUser: (data: ICreateUser) => IUser;
  getUser: (id: string) => IUser;
}
```

Вместо того, чтобы использовать реальную базу данных, мы заменяем её фиктивной реализацией: реализуем интерфейс при помощи заглушек. 

Тогда макет:
```ts
/* users-mock.ts */
import { ICreateUser } from '/* ... */';
import { IUser } from '/* ... */';
import { generateId } from '/* ... */';

const users = [];

/* заглушка */
const createUser = (data: ICreateUser): IUser => {
  const newUser = {
    ...data,
    _id: generateId(),
  };
  users.push(newUser);
  Promise.resolve(newUser);
}

/* заглушка */
const getUser = (id: string): IUser => Promise.resolve(users.find(user => user._id));

export default () => {
  createUser,
  getUser,
};
```
