Для получения документов индекса используется запрос `/_search`.

## Вид запроса, параметры запроса и ответ

### Все документы

Получить информацию о всех документах можно отправив GET-запрос, ничего не указывая.
```http
GET <ELASTICSEARCH_URL>/users/_search
```
Ответ выглядит следующим образом. 
```js
/* response body */
{
  "took": 80,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total": {
      "value": 2,
      "relation": "eq"
    },
    "max_score": 1.0,
    "hits": [
        {
          "_index": "users",
          "_type": "user",
          "_id": "Jntsi3ABpFL-9AlTdggH",
          "_score": 1.0,
          "_source": {
            "name": "Harry Smith",
            "job": "Dev Ops"
          }
        },
        {
          "_index": "users",
          "_type": "user",
          "_id": "J3tsi3ABpFL-9AlTdggH",
          "_score": 1.0,
          "_source": {
              "name": "Sam Brave",
              "job": "QA"
          }
        }
    ]
  }
}
```
Наиболее полезная информация лежит в свойстве `hits`: `hits.total.value` - количество всех докуметров, удовлетворяющих поиску, `hits.hits` - массив самих документов (хранятся в `_source`) и дополнительной информации о них. По умолчанию возвращается только 10 документов (см. [Пагинация](#пагинация)). 

### По конкретному слову (все поля документа)

Поиск по конкретному слову (слову `ops`) во всех полях (и `name`, и `job`).
```http
GET <ELASTICSEARCH_URL>/users/_search?q=ops
```

## Query DSL

Elasticsearch предоставляет **Query DSL** (Domain Specific Language) — предметно-ориентированный язык, позволяющий описывать запрос `query` в формате JSON и отправлять его в теле запроса (request body). Тело можно отравлять даже с GET-запросами.

Создатели Elasticsearch предлагают рассматривать Query DSL как **абстрактное синтаксическое дерево** (AST, Abstract Syntax Tree) **запросов**, которое имеет два типа **предложений** (clauses):
* **Листовые, конечные** (leaf query clauses). Предназначены для поиска определённого значения в определённом поле. Пример: `match`, `term`, `range`.
* **Составные** (compound query clauses). Предназначены для логического объединения листовых и других составных предложений. Пример: `bool`.

## Основные запросы Elasticsearch

### Запрос с match_all

Является самым простым запросом, поскольку возвращает все документы и не принимает какие-либо параметры.
```json
{
  "match_all": {}
}
```
Сам по себе избыточен, но может использоваться в комбинации с более сложными запросами.

### Запрос с match

В запрос с `match` передаётся текстовое, числовое, логическое значение или дата. Результатом поиска становятся документы, которые соответствуют переданному значению.

```json
{
  "match": {
    "fieldName": "search text"
  }
}
```

Если значением является текст, то он анализируется перед поиском. Поэтому запрос с `match` является стандартным для полнотекстового поиска.

Пример поиска пользователя с именем `Sam`. 
```http
```http
GET <ELASTICSEARCH_URL>/users/_search
Content-Type: application/json

{
  "query": {
    "match": {
      "name": "Sam"
    }
  }
}
```

Краткая версия запроса.
```http
GET <ELASTICSEARCH_URL>/users/_search?q=name:Sam
```

### Запрос с term

В запрос с `term` так же передаётся текстовое, числовое, логическое значение или дата.

В отличии от запроса с `match`, результатом запроса с `term` являются документы, которые содержат **точный терм** (exact term) в указанном поле.

```json
{
  "term": {
    "fieldName": "a"
  }
}
```

Текстовое значение, переданное в запрос с `term` *не анализируется*. Но данные документов уже проанализированы перед индексированием, поэтому поиск может выдать неверные результаты и лучше не использовать запрос с `term` для полей типа `text`, а использовать с типом `keyword`.

### Запрос с terms

Запрос с terms аналогичен запросу с term, но позволяет передать несколько допустимых значений вместо одного.
```json
{
  "terms": {
    "fieldName": ["a", "b"]
  }
}
```

Важно отметить, что при работе с массивом значений в документе свойства `term` и `terms` ищут не точное совпадение, а включение (contains). Оба примера выше с `term` и с `terms` включат в выборку документ со значением `["a", "b", "c"]`.

### Запрос с range

Запрос с `range` позволяет задать промежуток значений для конкретного поля. Результатом станут документы, удовлетворяющее промежутку.

Предоставляемые свойства для задания промежутка:
* `gt` - больше (greater than).
* `lt` - меньше (less than).
* `gte` - больше или равно (greater than or equal to).
* `lte` - меньше или равно (less than or equal to).

Пример запроса для поиска пользователей от 18 до 25 лет.
```js
GET <ELASTICSEARCH_URL>/users/_search
Content-Type: application/json

{
  "query": {
    "range": {
      "age": {
        "gte": 18,
        "lte": 25
      }
    }
  }
}
```

### Запрос с exists и missing

Запрос с `exists` (с `missing`) позволяет находить документы, у которых значение конкретного поля присутствует (отсутствует).
```json
{
  "exists": {
    "field": "username"
  },
  "missing": {
    "field": "bio"
  }
}
```

## Поиск по нескольким полям

Для поиска по нескольким полям используется запрос с `multi_match`.

```http
GET <ELASTICSEARCH_URL>/users/_search
Content-Type: application/json

{
 "query": {
   "multi_match": {
     "query": "sam",
     "fields": ["firstName", "lastName"]
   }
}
```

Можно задавать приоритеты полей при помощи символа `^`. В примере ниже `firstName` в два раза важнее `lastName`.
```json
"fields": ["firstName^2", "lastName"]
```

Если свойство `fields` не указано, то по умолчанию Elasticsearch берёт из маппинга все поля индекса, которые удовлетворяют типу искомого значения, и ищет по этим полям.

## Пагинация

За пагинацию отвечают параметры `size` и `from` запроса `_search`.

Параметр `size` определяет *количество возвращаемых документов*. Значение *по умолчанию*: *10*.

Свойство `from` отвечает за *смещение документов* (количество документов, которые должны быть пропущены).

### Пример пагинации

Создадим индекс `films` с объектами, имеющими поля `name` (keyword), `date`, `rating`.
```HTTP
PUT <ELASTICSEARCH_URL>/films
Content-Type: application/json

{
  "mappings": {
    "properties": {
      "name": { "type": "keyword" },
      "date": { "type": "date" },
      "rating": { "type": "float" }
    }
  }
}
```
Проиндексируем 3 фильма.
```HTTP
PUT <ELASTICSEARCH_URL>/films/_doc/_bulk
Content-Type: application/json

{ "index":{} }
{ "name": "film 1", "date": "2020-05-01T12:10:30Z", "rating": 4.5 }
{ "index":{} }
{ "name": "film 2", "date": "2020-06-30T16:00:45Z", "rating": 4.5 }
{ "index":{} }
{ "name": "film 3", "date": "2020-04-07T23:15:50Z", "rating": 4.7 }

```

Сделаем поисковый запрос к индексу и добавим параметр `size`.
```http
GET <ELASTICSEARCH_URL>/films/_doc/_search
Content-Type: application/json

{
  "size": 2
}
```
Результат
```json
[{
  "...": "...",
  "name": "film 1"
},
{
  "...": "...",
  "name": "film 2"
}]
```

Добавим также параметр `from`.
```http
GET <ELASTICSEARCH_URL>/films/_doc/_search
Content-Type: application/json

{
  "size": 2,
  "from": 1
}
```
Результат
```json
[{
  "...": "...",
  "name": "film 2"
},
{
  "...": "...",
  "name": "film 3"
}]
```

## Релевантность, контекст запроса и контекст фильтра

По умолчанию Elasticsearch ищет по **релевантности**, которая показывает, насколько запрос документ удовлетворяет поисковому запросу. 

Релевантность определяется **оценкой релевантности** (relevance score). Эта оценка зависит от самого поискового запроса, а также от контекста.

В **контексте запроса** (query context) предложения (query clauses) отвечают на вопрос "Насколько хорошо документ удовлетворяет запросу?". Помимо выяснения, соответствует ли документ запросу или нет, вычисляется *оценка релевантности* и записывается в *мета-свойство* `_score` в ответе.

Контекст запроса относится к параметру `query`.

В **контексте фильтра** (filter context) предложения отвечает на запрос "Удовлетворяет ли документ запросу?". Ответом является либо да, либо нет, и документ либо включается в выборку, либо нет в соответствии с ответом. 

Примером фильтра являются свойства `filter` и `must_not` для запроса с `bool`, о которых будет рассказано далее.

## Фильтрация

**Фильтр** (в программировании) — функция или программа, которая принимает структуру данных (обычно список) и возвращает новую структуру данных, содержащую только те элементы из исходной структуры, которые удовлетворяют заданному условию. 

<!-- На языке математики удовлетворение условия здесь означает, что логическая функция (boolean function), определяющая заданные условия, возвращает истиное значение (true). -->

Elasticsearch предоставляет составное предложение `bool`, которое позволяет задавать условия запроса и комбинировать их.

Предложение `bool` принимает объект, свойства которого обозначают логические операции.
* `must` — аналог логического И (AND, объединение условий).
* `should` — аналог логического ИЛИ (OR, пересечение условий).
* `must_not` — аналог логического НЕ (NOT, исключение). Выполняется в контексте фильтра, поэтому не высчитывает оценку релевантности. 

Также `bool` предоставляет свойство `filter`. Оно работает аналогично `must`, но в контексте фильтра, поэтому вычисление оценки релевантности игнорируется.

Каждое из указанных выше свойств может принимать объект, содержащий условие, или массив таких объектов.

Условия задаются при помощи свойств `match`, `term`, `terms`, `range`.

### Пример поиска специалиста с фильтрами

В следующем примере производится поиск специалиста, который:
* Имеет позицию `Software Enginer` И знает технологии `React`, `Vue` (must).
* Имеет опыт работы более одного года ИЛИ его желаемый уровень заработной платы не привышает 1000$ (should).
* Его возраст НЕ меньше 25 лет. (must_not).
```js
{
  "query" : {
    "bool" : {
      "must": [{
        "term": {
          "position": "Software Enginer"
        }
      }, {
        "terms": {
          "technology": ["React", "Vue"]
        }
      }],
      "should": [{
        "range": {
          "experience": {
            "gte": "1 year"
          }
        }
      }, {
        "range": {
          "desiredSalary": {
            "lte": "1000 USD"
          }
        }
      }],
      "must_not": {
        "range": {
          "age": {
            "lte": 25
          }
        }
      }
    }
  }
}
```

### Важное замечание про should

Несмотря на то, что `should` работает как логическое ИЛИ, позволяя задавать несколько условий, не все из которых должны выполняться одновременно, по умолчанию при наличии `must` ни одно из условий `should` не должно обязательно выполняться.

В этом случае `should` просто увеличивает значимость тех документов (увеличивая значение `_score`, которое по умолчанию = 1), которые удовлетворяют заданным условиям, но не исключает из выборки те документы, которые не условиям удовлетворяют.

Чтобы это исправить, нужно использовать свойство `minimum_should_match`. Оно позволяет задать минимальное количество условий `should`, которые должны выполниться, чтобы документ попал в выборку. 

По умолчанию свойство `minimum_should_match` = 1, если отсутствуют `must` или `filter`, 0 — иначе.

В примере ниже искомый специалист обязательно должен или иметь опыт больше года, или иметь желаемую зарплату меньше 1000$.
```js
{
  "query": {
    "bool": {
      "must": [],
      "should": [{
        "range": {
          "experience": {
            "gte": "1 year"
          }
        }
      }, {
        "range": {
          "desiredSalary": {
            "lte": "1000 USD"
          }
        }
     }],
     "minimum_should_match": 1
    }
  }
}
```

Если количество условий в `should` совпадает с `minimum_should_match`, то `should` вернёт те же документы, что и `must` при тех же условиях.

Если количество условий в `should` меньше, чем `minimum_should_match`, то вернётся пустая выборка.

## Сортировка

Elasticsearch позволяет при поиске *сортировать* документы *по одному* или *нескольким полям*. 

За **сортировку** (sort) отвечает параметр `sort`. 

Сортировка может производиться **по возрастанию** (`asc`, ascending) и **по убыванию** (`desc`, descending).
```js
{
  "sort" : [
    { "likes" : { "order" : "desc" } },
    { "date" : { "order" : "asc" } }
  ]
}
```

При сортировке по нескольким полям более приоритетным является то поле, которое указано первым в массиве.

### Сортировка полей-массивов

Elasticsearch также поддерживает сортировку полей, значениями которых являются массивы. В этом случае доступны следующие режимы (`mode`)
* `min` — сортировка по минимальным значениям массивов.
* `max` — сортировка по максимальным значениям массивов.
* `avg` — сортировка по средним значениям массивов.
* `sum` — сортировка по сумме значений массива.

```js
{
  "sort" : [
    { "values" : { "order" : "desc", "mode": "avg" } },
  ]
}
```

### Пример сортировки фильмов по рейтингу и дате

Воспользуемся примером из раздела с пагинацией.

Сортировка индекса `films` по убыванию рейтинга и даты.
```HTTP
GET <ELASTICSEARCH_URL>/films/_doc/_search
Content-Type: application/json

{
  "sort" : [
    { "rating" : { "order" : "desc" } },
    { "date" : { "order" : "desc" } }
  ]
}
```

Результат
```json
[{
  "...": "...",
  "name": "film 3"
},
{
  "...": "...",
  "name": "film 2"
},
{
  "...": "...",
  "name": "film 1"
}]
```

`film 3` является самым старым, но имеет выше рейтинг, а рейтинг приоритетнее даты, поскольку указан раньше в параметре `sort`.
`film 2` имеет такой же рейтинг, как и `film 1`, но по дате он новее.

## Обработка больших объёмов данных (scroll)

Один поисковой запрос в Elasticsearch не может обработать более 10000 элементов. 

Свойство `size` не может превышать 10000 элементов. Параметр `from`, отвечающий за пагинацию, не может захватить элементы с индексом, большим 10000. Свойство `total` также не может возвращать более 10000 элементов.

Можно повысить лимит, увеличив значение параметра `index.max_result_window value` в настройках индекса `settings`. Но делать это не желательно без крайней необходимости, поскольку поисковые запросы занимают память кучи (heap memory) и время пропорционально формуле `max(max_result_window, from + size)`. Если убрать лимит, то лимит памяти будет отсутствовать и кластер может упасть от перенагрузки. Лучше получать данные меньшими порциями. 

Когда необходимо обработать более 10000 документов одного индекса, следует использовать `Scroll API`.

**Scroll** позволяет возвращать большое количество результатов (или все результаты) аналогично курсору (cursor) в традиционных базах данных.

*Scroll* не используется для пользовательских запросов в режиме реального времени, но используется для получения больших объёмов данных, чтобы как-то обработать их (например, проиндексировать все документы индекса заново с обновлённой конфигурацией индекса или скопировать их для записи куда-либо).

**Контекст поиска** (Search context) — состояние, которые поддерживается в течение всей операции поиска в шарде. Чем больше параллельных (concurrent) поисковых операций выполняется, тем больше объектов поискового контекста существуют одновременно. Когда поисковая операция завершается, контекст поиска удаляется.

### Как работать со Scroll API

К обычному поисковому запросу следует добавить query-параметр `scroll` и в качестве значения передать туда время, которое будет жить поисковой контекст до следующего вызова.

Для оптимальной работы поисковой контекст должен жить как можно меньше, но этого времени должно хватать, чтобы обработать результат предыдущего результат запроса. Поставим 1 минуту в качестве времени жизни поискового контекста.
```http
GET <ELASTICSEARCH_URL>/index_name/_search?scroll=1m
```

Основные единицы времени
* `h` — час.
* `m` — минута.
* `s` — секунда.
* `ms` — миллисекунда.

В ответ на такой GET-запрос приходит ответ, который помимо привычных свойств содержит
* Достоверный `hits.total` (количество всех документов в индексе, не ограниченное лимитом в 10000).
* `_scroll_id` — идентификатор контекста поиска, который используется для получения следующей части результатов.

Каждый запрос со `scroll` возвращает в свойстве `_scroll_id` ссылку на текущий контекст поиска, по которой можно сослаться на следующую порцию результатов. Эта ссылка может меняться, а может оставаться прежней (то есть при двух идентичных последовательных запросах можно получить разные данные) — важно использовать её последнюю версию.

Для запроса со `scroll` контекст поиска создаётся при первоначальом (initial) запросе и живёт для выполения последующих запросов.

Для получения следующей порции результатов используется запрос следующего вида (в запросе отсутствует название индекса). Каждый такой запрос устанавливает своё время жизни следующего запроса. Время начинает считаться с момента, когда предыдущий запрос вернул данные.
```http
GET <ELASTICSEARCH_URL>/_search/scroll 

{
    "scroll" : "1m", 
    "scroll_id" : "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==" 
}
```

Когда время жизни контекста поиска истекает, получить дальнейшие документы при помощи `scroll` не получится. Выдаётся ошибка о том, что контекст поиска не существует.
```json
 {
   "type": "search_context_missing_exception",
   "reason": "No search context found for id [xxxx]"
}
```

Важно отметить, что использование `from` запрещено при использовании `scroll`.

После завершения работы со `scroll` можно удалить его вручную, не дожидаясь, пока истечёт время его жизни. Это освободит занимаемую память.
```http
DELETE <ELASTICSEARCH_URL>/_search/scroll

{
    "scroll_id" : "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
}
```

### Псевдокод для работы со scroll
Получать данные при помощи `scroll` можно рекурсивно примерно следующим образом.

```js
const getScrollDataRec = (documents, scroll_id) => {
  const { scroll_id, hits } = POST(`${ELASTICSEARCH_URL}/_search/scroll`, {
    scroll_id,
    scroll: '1m',
  });

  if (hits.hits.length) {
    documents.push(hits.hits);
    return getScrollDataRec(documents, scroll_id);
  }
  return documents;
};
  
const getAllDocuments = (indexName) => {
  const { scroll_id, hits } = GET(`${ELASTICSEARCH_URL}/${indexName}/_search?scroll=1m`);
  const documents = getScrollDataRec(hits.hits, scroll_id);
  return documents;
};
```
