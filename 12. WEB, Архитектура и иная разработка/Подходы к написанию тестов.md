# Подходы к написанию тестов
- [TDD](#tdd)
- [ATDD](#atdd)
- [BDD](#bdd)
- [Сравнение TDD, ATDD и BDD](#сравнение-tdd-atdd-и-bdd)
- [DDT](#ddt)
- [KDT](#kdt)

## TDD

**Test-Driven Development** (TDD) — разработка через тестирование; подход к разработке и тестированию, при котором сначала создаются тесты, которым должен удовлетворять код, затем его реализация.  

*TDD* имеет *итеративный процесс*. Сперва пишется тест на новый, ещё не реализованный функционал, а затем пишется минимальное количество кода (ничего лишнего) для его реализации. При успешном прохождении теста, можно задуматься о качестве кода и сделать его рефакторинг.

### Преимущества TDD
- Полное покрытие кода тестами.
- Заранее задумываемся об использовании кода.
- Хорошие тесты являются неплохим примером использования кода (что-то вроде документации).

### Пример TDD
Например, напишем тест для функции, которая должна возводить двойку в степень.
```js
const runTests = () => {
  assert.equal(pow2(0), 1, '2^0 = 1');
  assert.equal(pow2(1), 2, '2^1 = 2');
  assert.equal(pow2(2), 4, '2^2 = 4');
};
```
Теперь на основании теста пишется сама функция.
```js
const pow2 = (power) => {
  let result = 1;
  for (let i = 0; i < power; i++) {
    result *= 2;
  }
  return result;
}
```
Функция удовлетворяет тестам выше, добавим новые тесты.
```js
assert.equal(pow2(-1), 0.5, '2^(-1) = 0.5');
assert.equal(pow2(-2), 0.25, '2^(-2) = 0.25');
assert.equal(pow2(-3), 0.125, '2^(-3) = 0.125');
```
Дописываем нужный функционал.
```js
const pow2 = (power) => {
  let result = 1;
  if (power > 0) {
    for (let i = 0; i < power; i++) {
      result *= 2;
    }
  } else {
    for (let i = 0; i > power; i--) {
      result /= 2;
    }
  }
  return result;
}
```
Далее снова пишем тесты.

## ATDD

**Приемочное тестирование** (Acceptance Testing) — тестирование, направленное на проверку соответствия системы требованиям.

**Acceptance TDD** (ATDD) - разработчка через приёмочные тесты. Подход близок к TDD, но отличается тем, что привлекает тестировщиков, программистов и сторону заказчика к совместному написанию критериев принятия тестов до начала написания кода. 

Сперва придумываются критерий выполненной работы и критерий того, что она выполнена правильно. Эти критерии описываются доступным для понимания нетехническому человеку языком.

ATDD вносит ястность, что все участники проекта точно понимают, что необходимо сделать и реализовать.

## BDD

**Behavior-Driven Development** (BDD) — разработка, основанная на поведении; расширение подхода TDD, где особое внимание уделяется поведению системы в терминах бизнеса. Такие тесты обычно иллюстрируют и тестируют сценарии, интересные заказчику системы. Поэтому для BDD-тестов используются фреймворки (Chai, Mocha, Jest) с синтаксисом, понятным не только программисту, но и представителю заказчика. Обычно этот синтаксис похож на английский язык.

```js
const createArticle = title => ({ title, date: new Date() });

describe('createArticle', () => {
  const article = createArticle('Weather');
  it('should return an object', () => article.to.be.an('object'));
  it('the object should have a "date" and "title" properties', () => {
    expect(article).to.have.property('date'));
    expect(article).to.have.property('title'));
  });
});
```

## Сравнение TDD, ATDD и BDD

TDD-тесты пишутся программистами для программистов. Они не указывают, что конкретно нужно тестировать и как именно должны выглядеть и называться тесты.

BDD вдохновлено архитектурой DDD (Domain-Driven Design) и фокусируется на предметной области приложения, в то время как TDD фокусируется на сам код, реализацию.

ATDD фокусируется на отображении требований в приёмочных тестах и использует эти тесты для разработки. Вопрос, определяющий ATDD-тесты: "Система делает то, что от неё требуется?".

BDD ориентирован на клиента (customer-focused), в то время как ATDD больше ориентирован на разработчика (developer-focused) и часто использует те же технологии, что и TDD.

BDD-тесты могут быть написаны и поняты не только программистом, но и техническими менеджерами или тестировщиками, что позволяет убрать языковой барьер между всеми ними.

## DDT

**Data-Driven Testing (DDT)** — тестирование, управляемое данными; подход к архитектуре автоматизированных тестов, при котором тестовые данные хранятся отдельно от тестов (в файле или базе данных).

### Алгоритм DDT
* Часть тестовых данных извлекается из хранилища.
* Выполняется скрипт, в котором вызывается обычный тест с извлечёнными тестовыми данными.
* Сравниваются полученные (actual) результаты с ожидаемыми (expected).
* Алгоритм повторяется со следующим набором входных данных.

### Пример DDT

Перепишем функцию `pow2` из раздела TDD.
```js
const runTests = () => {
  assert.equal(pow2(0), 1, '2^0 = 1');
  assert.equal(pow2(1), 2, '2^1 = 2');
  assert.equal(pow2(2), 4, '2^2 = 4');
  /* ... */
};
```
Возводить двойку в степень можно до бесконечности (на самом деле не совсем, поскольку в JavaScript `MAX_SAFE_INTEGER = 2^53 - 1`), но писать все эти степени руками не хочется.  

Что можно сделать?  
Можно взять файл, содержащий степени двоек и подгружать данные из его.
```js
/* pow-data.txt */
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 ...
```
Пишем функционал, загружающий данные из файла и возвращающий их в виде массива.
```js
const fs = require('fs');

const readPowData = async (filename) => {
  const powData = await fs.readFile(filename, 'utf8'); // async, await доступны в fs с Node 11+
  return powData.split(' ');
};
```
Пишем функционал для тестов таким образом, чтобы можно было запускать их с массивом данных.
```js
const runTest = (power, expectedValue) => assert.equal(pow2(power, expectedValue), `2^${power} = ${expectedValue}`);

const runTests = (powDataArray) => {
  powDataArray.forEach((item, index) => {
    runTest(index, item);
  });
};
```
Считываем данные из файла и запустить тесты.
```js
let powDataArray = await readPowData('pow-data.txt');
runTests(powDataArray);
```
Загружаем данные из другого файла или же из другого источника, снова запускаем тесты.
```js
powDataArray = await readPowData('pow-data-2.txt');
runTests(powDataArray);

powDataArray = await getPowDataFromDB();
runTests(powDataArray);
```

## KDT

**Keyword-Driven Testing (KDT)** — тестирование, управляемое ключевыми словами; подход, использующий ключевые слова, описывающие набор действий, необходимых для выполнения определённого шага тестового сценария.

Для использования подхода нужно определить набор ключевых слов и сопоставить им действия (функции).

В KDT используется что-то вроде таблиц, чтобы ключевые слова могли иметь параметры, поэтому подход иногда называют **Table-Driven Testing (TDT)**.

### Алгоритм KDT
* Считываем ключевые слова вместе с их параметрами из таблицы.
* Последовательно вызываем связанные с ключевыми словами функции.

### Пример KDT

Пусть наш тестовый сценарий требует входа в пользовательский аккаунт, отправки двух сообщений на разные адреса и выход из аккаунта.  

Определяем ключевые слова: `Login`, `Send Email`, `Logout`.  

Сопоставим им функции.
```js
/* keyword "Login" */
const login = (username, password) => { /* ... */ };

/* keyword "Send Email" */
const sendEmail = (receiver, message) => { /* ... */ };

/* keyword "Logout" */
const logout = () => { /* ... */ };
```

Теперь можно описать тестовый сценарий, например, следующим файлом (одна строка - одно ключевое слово).
```js
/* user-test.txt */
Login         | user                  | pass123
Send Email    | another-user@mail.com | Hello!
Send Email    | my-friend@mail.com    | Hi!
Logout
```

Обработаем этот файл.
```js
const fs = require('fs');

const removeExtraSpaces = str => str.replace(/ +\| +/g, '|');

const readTestData = async (filename) => {
  const testData = await fs.readFile(filename, 'utf8');
 
  // убираем лишние пробелы в файле
  const formattedTestData = removeExtraSpaces(testData);

  // возвращаем массив строк файла
  return formattedTestData.split('\n'); 
};
```
Чтобы выполнять действие в зависимости от ключевого слова, можно использовать простую функцию с конструкцией `switch`.
```js
const makeAction = (keyword, params) => {
  switch (keyword) {
    case 'Login': return login(...params);
    case 'Send Email': return sendEmail(...params);
    case 'Logout': return logout();
  };
};
```
Осталось только считать строки из файла и выполнить то, что описано в каждой.
```js
  let rows = await readTestData('user-test.txt');
  rows.forEach((row) => {
    // выделяем ключевое слово и параметры в строке
    const [keyword, ...params] = row.split('|');
    // выполняем действие
    makeAction(keyword, params);
  });
```
Тут можно сделать вспомогательную функцию.
```js
const executeRows = (rows) => {
  rows.forEach((row) => {
    const [keyword, ...params] = row.split('|');
    makeAction(keyword, params);
  });
};
```
Теперь можно выполнять любые последовательности, состоящие из определённых нами ключевых слов.
```js
  let rows = await readTestData('user-test.txt');
  executeRows(rows);

  rows = await readTestData('another-test.txt');
  executeRows(rows);

  rows = ['Login|admin|admin', 'Logout'];
  executeRows(rows);
```
