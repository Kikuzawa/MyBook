## Поддерживаемый код

Наличие **поддерживаемого кода** (maintainable code base) означает возможность применения максимума концептуальных изменений с минимальным изменением кода, то есть изменение одного блока кода должно оказывать минимально возможное влияние на другие блоки. В таком случае изменения делаются проще и быстрее, а баги появляются реже.

**Связанность, зацепление** (coupling) отражает зависимость блоков кода друг от друга. Два блока кода **сильно связанны** (highly coupled), если изменения в одном блоке порождают изменения в другом, **слабо связанны** (loosely coupled), если один блок не зависит или почти не зависит от изменений другого. 

**Сплочёность, связность** (cohesion) отражает, насколько тесно связаны по смыслу функции одного модуля. **Низкая сплоченность** (low cohesion) характерна модулям, имеющим разные несвязнные обязанности, **высокая сплочёность** (high cohesion) — модулям, функции которых выполняют во многом похожие задачи.

### Основные принципы поддерживаемого кода
1) *Инкапсуляция* (encapsulation). Процесс сокрытия внутренних деталей реализации.  
2) *Слабая связанность* (low coupling). Достигается за счёт выбора правильного интерфейса.  
3) *Высокая сплочёность* (high cohesion).

Слово "**функциональный** (functional; блок кода, метод, класс и тд) отражает чисто техническую роль в приложении, оно не связано с предметной областью. Примеры функционального: слой (layer), фабрика (factory), View.

Слово "**концептуальный**" (conceptual; блок кода, метод, класс и тд) отражает бизнес-роль в приложении, оно напрямую связано с предметной областью (domain). Примеры концептуального: User, Article, Comment, Like.

Одна и та же вещь в зависимости от того, с какой стороны на неё смотреть, может быть функциональной и концептуальной одновременно.

**Пакет** — сгруппированный набор классов.  
**Модуль** — функциональный пакет.  
**Компонента** — концептуальный пакет.

Описанные принципы написания поддерживаемого кода часто применяются к отдельным классам, но также и к *пакетам* (*модулям*, *компонентам*). Это позволяет разрабатывать их максимально независимо друг от друга, разделяя обязанности между разными командами разработчиков. Выполнение принципов концептуально изолирует код, который в этом случае хорошо читается, легко тестируется и переиспользуется.

В *хорошо организованном проекте* (well-organised codebase) есть только одно конкретное место, где может лежать какой-то блок кода. 
Можно не знать точное местоположение, но есть только один логический путь, ведущий туда. Это позволяет избежать несогласованности данных, потерянного и дублированного кода, экономит время и нервы разработчиков.

## Принципы пакетов

Группируя классы в пакеты по каким-то критериям (концептуально), мы можем рассуждать об организации проекта на высшем уровне абстракции, управляя отношениями между этими пакетами.

### Принципы сплочёности пакетов (cohesion)
* **Reuse-Release Equivalency (RRE)**. Пакеты должны выпускаться и версионироваться отдельно друг от друга, чтобы всегда можно было выбрать старую версию пакета, если новая не корректно работает.
* **Common-Reuse Principle (CRP)**. Классы в пакете переиспользуются (reuse) вместе. Переиспользуешь один — переиспользуешь все.
* **Common-Closure Principle (CCP)**. Классы, изменяющиеся вместе, должны быть упакованы (packeged) вместе. Чтобы в случае изменений изменялся только один пакет, не затрагивая другие.

### Принципы связанности пакетов (coupling)
* **Acyclic-Dependencies Principle (ADP)**. Циклы в графе пакетных зависимостей недопустимы.
* **Stable-Dependencies Principle (SDP)**. Зависимости в направлении стабильности. Часто меняющиеся части системы должны зависеть от редко меняющихся (стабильных), но не наоборот. 
* **Stable-Abstractions Principle (SAP)**. Стабильные пакеты должны быть более абстрактными и содержать те классы и модули, которые можно расширять, а не те, которые должны изменяться. При изменении классов в пакете велика вероятность изменений их использования, а значит и изменений в зависимых пакетах.

## Принцип разделения ответственности (SoC)

**Принцип разделения ответственности** (Separation of Concerns, SoC) предполагает разделение приложения на функциональные блоки, как можно меньше перекрывающие функции друг друга.

Объектно-ориентированные языки разделяют ответственность между объектами, процедурные языки — между процедурами и функциями, микросервисная архитектура — между сервисами. Многие архитектуры стремятся отделить представление (Presentation) от бизнес-логики (Business Logic) приложения, некоторые архитектуры дополнительно разделяют бизнес-логику на предметную область (Domain) и на её конкретную реализацию. OOCSS разделяет структурные свойства (Structure) и свойства оформления (Skin). В сетевой модели OSI протокол HTTP отвечает за взаимодействие с пользователем — прикладной уровень (Application layer), за саму передачу данных отвечает протокол TCP — транспортный уровень (Transport  layer). 

## Принцип инверсии управления (IoC)

**Принцип инверсии управления** (Inversion of Control, IoC) предполагает передачу, дилегирование управления из одного места в другое, что позволяет достичь слабой связанности (loose coupling) кода.

Пример из жизни: человек может приготовить еду сам, а может просто заказать её, тогда ему не нужно заботиться о процессе приготовления пищи.  

Путь есть два класса: `Employee`, отвечающий за рабочих, и `Salary`, отвечающий за заработную плату. 
Пусть также каждый новый рабочий по умолчанию получает `500$`.
```ts
class Employee {
  salary: Salary;

  constructor() {
    this.salary = new Salary(500, '$');
  }

  getSalary() {
    return this.salary.toString();
  }
}

class Salary {
  value: number;
  currency: string;

  constructor(value: number, currency: string) {
    this.value = value;
    this.currency = currency;
  }

  toString() {
    return `${this.value}${this.currency}`;
  }
}

const emp: Employee = new Employee();
console.log(emp.getSalary());
```
Класс `Employee` напрямую создаёт объект класса `Salary` в своём конструкторе, что делает их сильно связанными. Изменения в `Salary` влекут за собой непосредственные изменения в `Employee`.

Более того, мы не можем изолированно протестировать класс `Employee`, поскольку не можем заменить создание объекта класса `Salary` заглушкой (stub) или заменить класс `Salary` макетом (mock).

Сделаем фабрику, которая будет создавать Salary-объекты.
```ts
const SalaryFactory = (value: number, currency: string): Salary => new Salary(value, currency);
```
и заменим строку `this.salary = new Salary(500, '$')` на `this.salary = SalaryFactory(500, '$')`.

Результат выполнения кода тот же, но мы ослабили связь между классами `Employee` и `Salary`, передав контроль над созданием объектов фабрике. Теперь, если класс `Salary` изменится, мы сможем оградить `Employee` от изменений, внеся изменения только в фабрику.

Например, конструктор класса `Salary` должен теперь принимать один параметр вместо двух: `new Salary('500$')`, тогда фабрика изменится следующим образом
```ts
const SalaryFactory = (value: number, currency: string): Salary => new Salary(`${value}${currency}`);
```

<!-- Также мы теперь можем протестировать `Employee` независимо от `Salary` при помощи следующей заглушки:
```ts
const SalaryFactory = (): object => ({ value: 500, currency: '$', toString() { return this.value + this.currency; } });
```-->

## Основные принципы ООП

### Инкапсуляция

**Инкапсуляция** скрывает те вещи, которые не должны быть получены или изменены извне. Обычно это детали реализации.

Простой пример реализации инкапсуляции на классах при помощи модификаторов доступа.
```ts
class BlackBox {
  private state: string = 'off';

  start(): void {
    this.state = 'on';
    console.log('Something started...');
  }
}

const box: BlackBox  = new BlackBox();
box.start();
console.log(box.state); // Error: Property 'state' is private and only accessible within class 'BlackBox'.
```
Свойство `state` инкапсулировано при помощи модификатора доступа `private` и до него нельзя достучаться снаружи, поскольку будет ошибка. Аналогично можно инкапсулировать методы класса. 

По умолчанию исползуется модификатор доступа `public`, который явно не пишется. У метода `start` установлен этот модификатор.

Модификатор доступа `private` не позволяет дочерним классам использовать переменные и методы родительского класса, что позволяет сокрыть некоторые его детали реализации. Если же нужно открыть доступ дочерним классам, используется модификатор `protected`. 
```ts
class BlackBox {
  protected state: string = 'off';

  start(): void {
    this.state = 'on';
    console.log('Something started...');
  }
}

class WhiteBox extends BlackBox {
  logState(): void {
    console.log(this.state);
  }
}

const box: WhiteBox = new WhiteBox();
box.logState(); // off
box.start();
box.logState(); // on
```
Как видно из примера выше, дочерний класс, имеющий доступ к скрытым деталям родительского, может их выставить на всеобщее обозрение. Поэтому с модификатором доступа `protected` нужно быть осторожным.

Инкапсуляция на примере функций в JavaScript выглядит ещё проще. Каждая функция по умолчанию создаёт новое лексическое окружение. Все переменные `var`, `let`, `const`, объяслвенные в ней, недоступны снаружи. Доступен лишь результат выполнения функции.
```js
const fn = () => {
  var a = 1;
  let b = 2;
  return a + b;
};

console.log(a); // ReferenceError: a is not defined
console.log(b); // ReferenceError: a is not defined
console.log(fn()); // 3
```

Жизненный пример инкапсуляции:  
Вентилятор. Его интерфейс представлен несколькими кнопками: вкл/выкл и иногда регулировка мощности. Пользователь просто жмёт на кнопки, а внутри вентилятора проиходят процессы, скрытые от глаз пользователя. В частности, работа редуктора и электродвигателя.

### Наследование

**Наследование** позволяет описать *новый* класс на *основе* уже *существующего*.

*Существующий* класс в этом случае называют **базовым** (base), **родительским** (parant), **суперклассом** (superclass).
*Новый* класс — **производным** (derived), **дочерним** (child), **подклассом** (subclass).

*Наследование* — включение поведения и состояния родитеского класса в дочерний. **Поведение** представлено *методами*, **состояние** — *свойствами*.

Дочерний класс включает в себя свойства и методы родительского класса, которые он может доопределять, переопределять или же дополнять своими.

*Наследование* — один из способов *повторного использования кода*. Оно влечёт за собой *сильную связанность* кода: если нужно *изменить класс*, то также придётся *изменить* его *дочерние классы*.

Ниже представлены класс `Point`, описывающий точку с координатами `(x, y)`, и его дочерний класс `ColorfullPoint`, представляющий точку какого-то цвета.
```ts
class Point {
  x: number = 0;
  y: number = 0;
  
  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }

  setX(x: number) {
    this.x = x;
  }

  setY(y: number) {
    this.y = y;
  }
}

class ColorfullPoint extends Point {
  color: '#000';

  constructor(x: number, y: number, color: string) {
    super(x, y);
    this.color = color;
  }
}
```

### Полиморфизм

**Полиморфизм** — способность предоставлять один и тот же интерфейс для различных реализаций.

В программировании есть 3 типа полиморфизма:
* *Ad-hoc*
* *Параметрический*
* *Полиморфизм подтипов*

В ООП *полиморфизм подтипов* называется **полиморфизмом**, *параметрический полиморфизм* — **обобщённым программированием**. 
Понятия *Ad-hoc-полиморфизм* в рамках ООП нет.

**Ad-hoc-полиморфизм** поддерживается посредством перегрузки (overload) функций, операторов и методов, в слаботипизированных языках - неявное приведение типов.

* Перегрузка операторов в C++.  

Задана структура `Point`, описывающая точку на плоскости `(x, y)`.  
В примере перегружаются операторы сложения и вывода для структуры `Point`.
```cpp
#include <iostream>
using namespace std;

typedef struct point {
  int x;
  int y;

  point(int x0 = 0, int y0 = 0) {
    x = x0;
    y = y0;
  }
} Point;

/* перегрузка оператора вывода */
ostream& operator << (ostream &stream, const Point &p) {
  return stream << "(" << p.x << ", " << p.y << ")";
}

/* перегрузка оператора сложения */
Point operator + (const Point &A, const Point &B) {
  return Point (A.x + B.x, A.y + B.y);
}

int main() {
  Point A(1, 2);
  Point B(3, 4);
  cout << A + B; /* выведет (4, 6) */
  return 0;
}
```

* Перегрузка функций и методов в TypeScript.

Задан класс `Point`, описывающий точку на координатной прямой `(x)`.  
В примере перегружены методы и функции, связанные со сложением точек.
```ts
/* перегрузка функции */
function sum(A: Point, B: Point): Point;
function sum(A: Point, B: number): Point;
function sum(A: any, B: any): Point {
    return new Point(A + B);
}

class Point {
  x = 0;
  constructor(x: number) {
    this.x = x;
  }
  valueOf() { return this.x; }
  /* перегрузка методов */
  add(point: number): void;
  add(point: Point): void;
  add(point: any): void {
    this.x += point;
  }
}

const A = new Point(1);
A.add(10);
console.log(A); // // Point { x: 11 }
console.log(sum(A, 6)); // Point { x: 17 }

const B = new Point(20);
console.log(sum(A, B)); // Point { x: 31 }
```

* Неявное приведение типов в JavaScript.
```js
1 + "7" // 17
1 + true // 2
true == 'true' // false
```

**Параметрический полиморфизм** позволяет определять функцию или тип данных обобщённо (generically), чтобы их значения обрабатывались идентично вне зависимости от их типа.

```ts
function valueOf<T>(obj: T): any {
  return obj.valueOf();
}

/* экземпляр класса Point из примеров выше */
const A = new Point(17);
console.log(valueOf<Point>(A));
```
```ts
interface Item<T> {
  field: T;
  method(prop: T) => T; 
}

class NumberItem extends Item<number> {
  field: number;
  method(prop: number) => prop + 1;
}

```
```ts
type Props = { /* ... */ };
type State = { /* ... */ };

class MyComponent extends React.Component<Props, State> { /* ... */ }
```

**Полиморфизм подтипов**, **полиморфизм включения** — свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
```ts
abstract class Shape {
  abstract draw(): void;
}

class Triangle extends Shape {
  draw(): void {
    console.log('drawing a triangle');
    /* ... */
  }
}

class Circle extends Shape {
  draw(): void {
    console.log('drawing a circle');
    /* ... */
  }
}

const shapes: Shape[] = [new Triangle(), new Circle()];
shapes.forEach(shape => shape.draw());
```

## Основные термины ООП

### Ассоциация

**Ассоциация** (Association) — связь, отношение между двумя объектами. Слова «один-к-одному» (one-to-one), «один-ко-многим» (one-to-many), «многие-к-одному» (many-to-one), «многие-ко-многим» (many-to-many) определяют связь между объектами.

Примеры:
* У человека только одна жизнь (один-к-одному).
* В библиотеке много книг (один-ко-многим).
* Несколько книг могут принадлежать одному писателю. (многие-к-одному)
* Здесь есть десятки ресторанов, в каждом из которых есть по-своему интересные блюда (многие-ко многим).

### Агрегация

**Агрегация** (Aggregation) является формой ассоциации, когда один объект "имеет" (отношение "has-a") имеет ссылку на другой объект. Содержащий объект иногда называют **контейнером**.

Агрегация не подразумевает владения: оба объекта могут существовать независимо друг от друга. Уничтожение контейнера не означает уничтожение содержащегося в нём объекта.
```js
class Book {
  constructor(name, author) {
    this.name = name;
    this.author = author;
  }
}

/* книги созданы вне класса Library, поэтому они не зависят
от его экземпляров */
const books = [
  new Book({ name: 'Martin Eden', author: 'Jack London' });
  new Book({ name: '1984', author: 'George Orwell' });
];

class Library {
  books = [];
  /* одним из способов передачи книг при агрегации является
  передача через конструктор */
  constructor(books) {
    this.books = books;
  }
}

let library = new Library(books);
library = null; // уничтожение экземпляра класса Library 
console.log(books); // книги продолжают существовать
```

*Агрегация* на примере *React*. *Компоненту* можно представить как *класс* (функцию), *блоки* можно представить как *объекты*, *экземпляры класса* (константы).  
```jsx
/* компонента (класс, функция) */
const Text = ({ title }) => (<span>{title}</span>);

/* блок (экземпляр класса, константа) */
const helloBlock = (<Text title="Hello" />);

const TextWrapper = () => (
  <div>{helloBlock}</div>
);
```
Блок `helloBlock` создаётся вне компонента `TextWrapper`, поэтому в случае создания и уничтожения блока `<TextWrapper />`, `helloBlock` не уничтожится вместе с ним (он может быть удалён сборщиком мусора, если не будет использован в других местах, но всё же возможность его использования имеется).

### Композиция

**Композиция** (Composition) является *более строгой формой агрегации*, при которой *содержащийся объект не может существовать без своего контейнера*: *уничтожается вместе с контейнером*.

```js
class Book {
  constructor(name, author)
}

class Library {
  books = [];
  constructor() {
    /* книги созданы в конструкторе, поэтому при уничтожении
    объекта они не смогут больше использоваться и будут удалены */
    this.books = [
      new Book({ name: 'Martin Eden', author: 'Jack London' });
      new Book({ name: '1984', author: 'George Orwell' });
    ];
  }
}

let library = new Library();
library = null; // книги удаляются и к ним нет доступа
```

Примеры композиции:
* Квартира не может существовать без дома.
* Работник не может существовать без места работы.

Пример использования композиции в React.
```jsx
/* Экземпляр компонента Title создаётся внутри Article. */
const Article = ({ title }) => (<Title>{title}</Title>);

class App {
  state = {
    isShown: false,
  };

  render() {
    return (
      <div>
        { this.state.isShown
          ? <Article title="notes" />
          : null }
      </div>
    );
  }
};

ReactDOM.render(<App />, document.getElementById('root'));
```
```js
this.setState({ isShown: true });
/* Когда экземпляр компонента Article создаётся,
экземляр компонента Title создаётся вместе с ним. */

this.setState({ isShown: false });
/* Когда экземпляр компонента Article уничтожается (unmount),
экземляр компонента Title уничтожается вместе с ним. */
```

### Обобщение, Специализация и Наследование

**Обобщение** (Generalization) — процесс извлечения общих характеристик (shared characteristics) из нескольких похожих классов и размещения этих характеристик в **обобщённом суперклассе** (generalized/generic/general superclass). Похожие классы становятся его подклассами (subclasses). 

*Общими характеристиками* могут выступать *атрибуты*, *методы* и *ассоциации*.

Общие характеристики перечислены только в суперклассе, но они также применяются и к его подклассам.

**Наследование** (Inheritance) — механизм, передающий характеристики суперкласса его подклассам. Подклассы **наследуют** характеристики свеого суперкласса.

Примет *обобщения*: собака и лошадь являются домашними животными, самолёт и машина являются транспортными средствами.

*Обобщение* использует *отношение "is-a" (является)*.

*Horse is an Domestic Animal, Dog is an Domestic Animal* (класс `DomesticAnimal` — *обобщённый суперкласс*, `Horse`, `Dog` — его *подклассы*).
```js
class DomesticAnimal {}
class Horse extends DomesticAnimal {}
class Dog extends DomesticAnimal {}
```

**Специализация** (Specialization) — *процесс создания новых подклассов из* уже *существующего*. 

*Специализация используется*, если *определённые характеристики* (атрибуты, методы и ассоциации) *применяются только* к *некоторым* *объектам класса*. В таком случае *может быть создан специальный подкласс* (special/specific subclass).

*Специализация не* всегда *означает*, что в *подклассе* должны быть *поля*, которых *нет* в *суперклассе*. *Фиксация конкретных полей суперкласса* в *дочернем подклассе* также *является специализацией*.

*Специализация* может *достигаться* за счёт *наследования* и *композиции*.

Пример *специализации* за счёт *композиции* в *React*.
```jsx
/* два параметра */
const Mesage = ({ title, text }) => (
  <div>
    <p>{title}</p>
    <p>{text}</p>
  </div>
);

/* один параметр фиксирован */
const WelcomeMessage = ({ text }) => (
  <Message title="Welcome" text={text} />
);
```

### Реализация

**Реализация** (Realization) — связь между классом и каким-то объектом, содержащим сведения о том, что должно быть реализовано в классе. Этот объект обычно называют **интерфейсом** (Interface).
```ts
/* пример на typescript */
interface IArticle {
  title: string;
  getTitle: () => string;
}

class Article implements IArticle {
  title: string = '';
  getTitle(): string {
    return this.title;
  }
}
```

Говорят, что *класс реализует* (implements) *интерфейс*.

## Зависимость

**Зависимость** (Dependency) — связь между двумя классами, при которой изменение структуры или поведения одного класса влияет на другой класс. 

Зависимость работает только в одну сторону. 

Зависимым является класс, использующий другой класс.
 
### Абстракция

**Абстрагировать** объект означает отбросить его маловажные, несущественные детали, чтобы выделить самую важную часть. Что войдёт в "самую важную часть", зависит от решаемой задачи.

**Абстракция** — использование только тех характеристик объекта (свойств и методов), которые с необходимой точностью представляют его данные в системе.

*Абстракция* позволяет работать с объектами, не вдаваясь в особенности их реализации.

У всего есть **уровни абстракции**.

Пытаясь что-то описать, мы выбираем какой-то уровень абстракции.
Например, мы можем описать птицу следующим образом.
```ts
class Bird {
  age: number;
  size: number;
  name: string;
}
```
Сейчас мы создали некоторую абстракцию, но также можем добавить некоторые другие детали, чтобы выйти на новый уровень абстракции.
```ts
class Bird {
  age: number;
  size: number;
  name: string;
  eat(): void { /* ... */ };
  sleep(): void { /* ... */ };
}
```
Хорошо подумав, мы решаем, что одного класса для нашего приложения мало: необходимы более конкретные виды птиц (чайка, лебедь). Помечаем класс `Bird` как абстрактный, чтобы нельзя было создавать экземпляры "неконкретных" птиц (`new Bird()`), а также помечаем некоторые его методы (в приложении голубь и лебедь могут спать и есть по-разному, пусть в них это и определяется).
```ts
abstract class Bird {
  age: number;
  size: number;
  name: string;
  abstract eat(): void;
  abstract sleep(): void;
}

class Gull extends Bird {
  eat(): void {
    console.log('eating a fish');
  }

  sleep(): void {
    console.log('sleep on the mountain');
  }
}

class Dove extends Bird { /* ... */ }
```
Затем мы решаем, что есть плавающие и летающий птицы.
```ts
abstract class Bird { /* ... */ }

abstract class SwimmingBird extends Bird {
  abstract swim():void;
}

abstract class FlyingBird extends Bird {
  abstract fly():void;
}
```
Поскольку в TypeScript множественное наследование запрещено, а в абстрактных классах у нас нет реализованных методов, используем интерфейсы.
```ts
interface IBird {
  age: number;
  size: number;
  name: string;
  eat: () => void;
  sleep: () => void;
}

interface ISwimmingBird extends IBird {
  swim: () => void;
}

interface IFlyingBird extends IBird {
  fly: () => void;
}

class Gull implements ISwimmingBird, IFlyingBird { /* ... */ }
class Starling implements IFlyingBird { /* ... */ }
class Chicken implements IBird { /* ... */ }
```
Можно продолжать детализировать и дальше, если этого требует приложение.


## CRP: Композиционный принцип повторного использования

**Composite Reuse Principle** (CRP) гласит, что *классам* следует *достигать полиморфного поведения* и *переиспользуемости кода* за счёт *композиции* классов, а *не наследования*.

### Способ реализации CRP
Создаётся множество интерфейсов, описывающих поведение системы. Классы выборочно реализуют эти интерфейсы, формуруя таким образом доменные модели. 

При таком подходе *интерфейсы помогают добиться полиморного поведения*.

Если нужно создать класс, похожий на уже существующий, но в то же время имеющий некоторые изменения, можно просто создать новый класс, по-своему реализующий тот же интерфейс. 

Вероятно, при использовани композиции часть кода будет дублироваться, но он будет менее связанным, а значит более поддерживаемым.

### Преимущества композиции над наследованием
* **Переиспользуемость кода**. Множественное наследование запрещено во множестве языков программирования из-за ромбовидной проблемы (diamond problem): два родительских класса могут иметь метод с одинаковым названием и не известно, какой из них нужно унаследовать. По этой причине есть возможность наследоваться только от одного класса. Композицию же можно использовать неограниченное количество раз.
* **Тестирование**. Композицию можно просто подменить тестовым объектом (заглушкой, реализующей интерфейс), наследование требует использование родительского класса, заменить который нельзя и придётся напрямую его импортировать.
* **Инкапсуляция**. Наследование нарушает принцип инкапсуляции, так как дочерний класс зависит от поведения своего родительского класса и изменение последнего повлечёт за собой непосредственное изменение дочернего класса. Модификаторы доступа частично решают эту проблему.

## Принципы SOLID

Принципы SOLID были разработаны Робертом С. Мартином.

* **Single Responsibility Principle** (SRP, Принцип единственной ответственности).
* **Open-Closed Principle** (OCP, Принцип открытости-закрытости).
* **Liskov Substitution Principle** (LSP, Принцип подстановки Барбары Лисков).
* **Interface Segregation Principle** (ISP, Принцип разделения интерфейса).
* **Dependency Inversion Principle** (DIP, Принцип инверсии зависимостей).

### SRP: Принцип единственной ответственности

Должна быть лишь одна причина изменить класс (функцию, метод), то есть класс должен быть ответственен лишь за что-то одно. Если у класса несколько причин для изменения, то он отвечает за несколько задач.

Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются сильно связанны друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.

Пусть есть массив каких-то объектов и функция поиска объекта в этом массиве по `id`.
```js
import _ from 'lodash';

const items = [{
  id: '1',
  name: 'n',
  description: 'd',
}, /* ... */];

const findItem = (id) => {
  /* находим элемент */
  const item = items.find(item => item.id === id);
  /* убираем ненужные поля */
  return _.omit(item, ['description']);
}

const item = findItem('1');
```
Функция `findItem` нарушает принцип единственной ответственности, поскольку совершает две операции: поиск элемента и удаление ненужных полей из найденного объекта. Если изменятся поля, которые не нужно возвращать, то изменится и функция `findItem`. Если изменится поле `id` (например, `_id`, `username`), то `findItem` снова изменится. Имеем две причины для изменения. Такой код сильно связан и его сложно переиспользовать. 
Разбиение функции `findItem` на две сделает код более переиспользуемым и менее связанным. Пример можно применить и к классу, создав класс `Items` с методами `findItem` и `omitFields`.
```js
const findItem = id => items.find(item => item.id === id);
const mapItem = (item, fields) => _.omit(item, fields);

const searchResult = findItem('1');
const item = mapItem(searchResult, ['description']);
```

Рассмотрим более неоднозначный пример. Допустим, мы отправляем HTTP-запрос на создание пользователя к серверу. Часто такой запрос сперва создаёт пользователя, а затем возвращает его. То есть по сути совмещает в себе две операции: создание и получение пользователя. Несмотря на то, что это является оптимизацией (один запрос к серверу вместо двух), это также является нарушением принципа единственной ответственности. Такую логику можно разбить на Команду (Comand), которая совершает действие (создаёт пользователя) и ничего не возвращает, и Запрос (Query), который получает пользователя из базы данных и возвращает его. Правда, чаще всего выбирают оптимизацию.
```js
const createUser = async (req, res) => {
  try {
    const user = await userRepository.create(req.body);
    return user;
  } catch (e) {
    res.send(404);
  }
};
```
Существуют и исключения из правила. Например, структура данных Стек имеет функцию `pop()`, которая удаляет элемент и возвращает его. Такое поведение функции общепринято и считается ожидаемым.

Минусом подхода является увеличение количества классов (функций, методов), которые хоть и делают код более переиспользуемым, но усложняют его в целом.

### OCP: Принцип открытости-закрытости

Программные сущности (классы, модули, функции) должны быть открыты для расширения (extension) и закрыты для модификации (modification).

Это довольно сложный в реализации принцип.  
Его идея заключается в том, что следует код, который будет достаточно гибким для изменений в будущем. Новый функционал должен вносить минимум изменений в уже существующий. Но обычно новый функционал не всегда просто предсказать. 

Пытаясь продумать многие случаи использования наперёд, разработчик часто создаёт такие вещи, которые в данный момент ему не нужны, а в будущем могут даже и не понадобиться. При этом они увеличивают сложность кода, требуют время на написание и поддержку. Нелегко найти баланс между написанием гибкого кода и написанием ненужного кода, поэтому у принципа открытости-замкнутости есть противоположный принцип - принцип YAGNI.

Пусть нужно необходимо написать класс, описывающий личного ассистента с возможностью приветствия.  
Создаём класс `Assistant` с методом для приветствия `sayHi`.
```ts
class Assistant {
  sayHi(): void {
    console.log('Hi!');
  }
}
```
Пока сложно предсказать, как изменится класс. Можно только догадываться.

Требования изменились и нужно написать функциональность для прощания `sayGoodbye`.
```ts
class Assistant {
  sayHi(): void {
    console.log('- Hi! Nice to meet you.');
  }
  sayGoodbye(): void {
    console.log('- Bye! See you later.');
  }
}
```
Часть логики повторилась и теперь понятно, что в будущем могут появиться новые методы (например, поблагодарить).
Сделаем класс более гибким для дальнейшего расширения.
```ts
class Assistant {
  say(phrase): void {
    if (phrase === 'hi') {
      console.log('- Hi! Nice to meet you.');
    } else if (phrase === 'bye') {
      console.log('- Bye! See you later.');
    }
  }
}
```
Теперь на каждую новую фразу не создаётся новый метод: есть один метод, который обрабатывает все фразы. Но с появлением новых фраз метод будет бесконечно изменяться и расти (новые `else-if` блоки), а следовательно и класс. Более того сами фразы могут измениться в будущем или же разные экземпляры класса `Assistant` захотят произносить разные фразы.

Упрощаем метод `say`, вынося фразы за его пределы.
```ts
const SARA_PHRASES = {
  hi: 'Hi! Nice to meet you.',
  bye: 'Bye! See you later.',
};

class Assistant {
  say(phrase: string): void {
    console.log(`- ${phrase}`);
  }
}

const Sara: Assistant = new Assistant();
Sara.say(SARA_PHRASES.hi);
```

Пусть помимо слов в привествии, появляется дополнительное действие (например, похмахать рукой), тогда можно создать новый метод, не затрагивая старый код.
```ts
great(phrase: string): void {
  this.say(phrase);
  waveHand();
}
```

Удалось сделать достаточно гибкий к изменениям класс. Eсли в дальнейшем понадобится дополнительно добавить локализацию, заменить фразу, считать фразы из файла или получать их по запросу, потребуется минимум изменений в уже написанном коде.


### LSP: Принцип подстановки Барбары Лисков

**Принцип Барбары Лисков**.
> Пусть `q(x)` — свойство, справедливое для любых объектов `x`, принадлежащих типу `T`, тогда свойство `q(y)` должно быть также справедливо для любых объектов `y`, принадлежащих типу `S`, являющимся подтипом типа `T`.

```math
q(x) = true ∀x ∈ T => q(y) = true ∀y ∈ S, ∀S ⊂ T
```

*Роберт Мартин переформулировал принцип Барбары Лисков* следующим образом.
> Функции, использующие базовый тип, должны иметь возможность использовать его подтипы, не зная об этом.

Рассмотрим пример с *птицами*. Есть *класс* (базовый тип) `Bird` и его *дочерний класс* (подтип) `Chicken`.
```ts
import { loadAnimation, showAnimation } from '/* ... */';

const animateFlight = (bird: Bird) => {
  /* подгружается анимация полёта птицы и отображается */
  const animation = loadAnimation(bird.constructor.name);
  showAnimation(animation);
};

class Bird {
  makeSound(): void {};
  fly(): void {
    animateFlight(this);
  }
}

class Chicken extends Bird {
  constructor() { 
    super();
  }
  
  /* переопределение метода родительского класса */
  makeSound(): void {
    console.log('cackle');
  }
}
```
Функция `animateFlight(bird: Bird)` использует базовый тип `Bird`. Опираясь на высказывание Роберта Мартина, функция `animateFlight` не должна знать о том, что использует класс `Chicken` вместо `Bird`, то есть в ней не должно быть проверки принадлежности к конкретному классу (например, `if (bird instanceof Chicken)`).

Класс `Bird` имеет метод `fly` (летать), `Chiken` наследует этот метод. Тем не менее, пример ниже выдаст ошибку.
```ts
animateFlight(new Bird());
animateFlight(new Chicken()); // ошибка
```
*Курица не умеет летать* и функция `animateFlight()` *не имеет* подходящей *анимации* для её *полёта*. Такие случаи придётся *обрабатывать отдельно* для *нелетающих птиц*. То есть мы не можем использовать функцию `animateFlight()` с `Chicken`, но можем использовать её с родительским классом `Bird`. Это свидетельствует о *плохо подобранной абстракции*, *нарушающей принцип Барбары Лисков*.

Чтобы принцип *соблюдался*, следует убрать метод `fly()` из класса `Bird` (поскольку не всем птицам характерно летать). 

Одним из способов это сделать является перенос метода `fly()` из `Bird` в новый подкласса `FlyingBird`. В этом случае используется принцип разделения интерфейса. 
```ts
class Bird {
  makeSound(): void {};
}

class Chicken extends Bird {
  makeSound(): vold { /* ... */ }
}

class FlyingBird extends Bird {
  fly(): void { /* ... */ }
}
```
Поскольку полёт теперь не является обязательным поведением птицы `Bird`, но является для `FlyingBird`, меняем также тип параметра у функции `animateFlight()`. 
```ts
const animateFlight = (bird: FlyingBird) => { /* ... */ };

class Dove extends FlyingBird {
  makeSound(): vold { /* ... */ }
}

animateFlight(new FlyingBird());
animateFlight(new Dove());
```
Функция `animateFlight` не может работать с `Chiken`, но она не может работать и с `Bird`: принцип Барбары Лисков не нарушен. 

<!--Вообще говоря, класс `Bird` следовало бы сделать абстрактным вместе с его методами, поскольку в подобранной абстракции рассматриваются конкретные виды птиц (голубь, курица и так далее). Более того, и спользуется функция с анимацией полёта и трудно представить полёт какой-то абстрактной птицы. Но в случае абстрактного класса `Bird` невозможно было бы создать экземпляр `new Bird()` и передать -->

<!-- не существует неконкретной птицы: каждая птица имеет название, внешний вид, способы передвижения. Невозможно также представить анимацию полёта `Bird` (в примере мы предполагаем, что она задана). Но в случае абстрактного класса `Bird `невозможно было бы создать его экземпляр `new Bird()`, а следовательно и заменить его на `new Chicken()`. -->

### ISP: Принцип разделения интерфейса

Нужно создавать узкоспециализированные интерфейсы, предназначенные для конкретных целей.  

Клиент не должен зависеть от тех элементов интерфейса, которые он не использует.

Например, имеем следующий интерфейс.
```ts
interface IPerson {
  sleep: () => void;
  watchFilm: () => void;
  visitMeeting: () => void;
  writeCode: () => void;
  testCode: () => void;
}
```
Допустим, нужно написать класс `Worker`, который описывает программиста и реализует интерфейс `IPerson`. В этом случае он также реализует методы `sleep()` и `watchFilm()`, хоть они ему и не нужны. Получается, что имеем лишний код, который увеличивает сложность приложения.
```ts
class Worker implements IPerson {
  visitMeeting() { /* ... */ }
  writeCode() { /* ... */ }
  testCode() { /* ... */ }
  
  watchFilm() {
    throw new UnsupportedActionError();
  }
  sleep() {
    throw new UnsupportedActionError();
  }
}
```
Интерфейс `IPerson` выше называют жирным (fat) или загрязнённым (polluted). Такие интерфейсы по возможности следует разбивать на несколько. Разбиение проводится до тех пор, пока интерфейсы не будут содержать только действительно необходимые им методы.
```ts
interface IPerson {
  sleep: () => void;
  watchFilm: () => void;
}

interface IWorker {
  visitMeeting: () => void;
  writeCode: () => void;
  testCode: () => void;
}
```

Недостатком принципа считается рост количества интерфейсов. Их может стать слишком много.

### DIP: Принцип инверсии зависимостей

Зависимость должна идти в сторону абстракции, а не чего-то конкретного.

Абстракции не должны зависеть от деталей.  
Детали должны зависеть от абстракций.

Модули верхних уровней (high-level modules) не должны зависеть от модулей нижних уровней (low-level modules).  
Оба типа модулей должны зависеть от абстракций.

Пусть у нас есть класс `Service` (модуль верхнего уровня), который использует класс `Repository` (модуль нижнего уровня) и, соответственно, зависит от него. Аналогично, класс `Repository` использует класс-сущность `User`.
```ts
class UserService {
  repo: UserRepository;
  constructor () {
    this.repo = UserRepositoryFactory();
  }
}

const UserRepositoryFactory = (): UserRepository => new UserRepository();

class User {
  id: string;
  name: string;
  constructor (id: string, name: string) {
    this.id = id;
    this.name = name;
  }
}

class UserRepository {
  constructor () {}
  getUserById(id: string): User { /* ... */ }
}
```
В примере выше использован паттерн проектирования "Фабрика", чтобы вынести логику создания объектов из сервиса (Inversion of Control).

Выделим абстракцию, определив интерфейсы.
```js
interface IUser {
  id: string;
  name: string;
}

interface IUserRepository {
  getUserById(id: string): IUser
}
```
Заменяем в `UserService` строчку `repo: UserRepository` на `repo: IUserRepository` и в `UserRepository` строчку `getUserById(id: string): User` на `getUserById(id: string): IUser`. Теперь модули верхних уровней не зависят от модулей нижних уровней, а зависят от интерфейсов, то есть абстракции.

Заменим также строчку `class User {}` на `class User implements IUser {}`,  строчку `class UserRepository {}` на `class UserRepository implements IUserRepository {}`. Теперь модули нижних уровней (классы; детали реализации) зависят от абстракции, но не наоборот.

## Принцип DRY

**Принцип DRY** (Don’t repeat yourself) переводится как "Не повторяйся" и нацелен на снижение повторения информации различного рода.
> Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

«Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы».

Когда DRY применяется правильно, изменение элемента системы не требует изменений в других, логически не связанных элементах.

Нарушение принципа DRY называют WET (Write Everything Twice), переводящееся как "Пиши всё дважды".  
Игра слов: dry — сухой, wet — влажный.

Простой пример применения принципа DRY: видишь часто повторяющийся код — выносишь его в функцию или переменную.

## Принцип KISS

**Принцип KISS** (keep it short and simple) переводится как "Держи это коротким и простым" и утверждает, что в большинстве случаев система работает лучше, если отаётся простой, поэтому в области проектирования простота должна быть одной из ключевых целей и следует избегать ненужной сложности.

## Принцип YAGNI

**Принцип YAGNI** (You aren't gonna need it) переводится как "Вам это не понадобится" и утверждает, что не следует добавлять функциональность пока не возникнет необходимость в этом.
> Always implement things when you actually need them, never when you just foresee that you need them.

«Всегда реализуй вещи, когда ты действительно в них нуждаешься, никогда, если ты предвидишь, что они тебе понадобятся».

Написание ненужного в данный момент кода требует время и поддержку, которые могли быть затрачены на важные в данный момент вещи. Такой код ограничивает то, что может быть сделано в будущем, увеличивает сложность приложения.
