# Асинхронность в NodeJS

## Функция обратного вызова (callback)
- [О функциях обратного вызова](#о-функциях-обратного-вызова)
- [Паттерн error-first callback](#паттерн-error-first-callback)
- [Callback hell](#callback-hell)

### О функциях обратного вызова

**Функция обратного вызова**, **колбэк** (англ. callback, cb) — *функция*, которую *передают аргументом* в *другую функцию*. 

Функция обратного вызова может быть вызвана в любое время, когда это будет необходимо.

*Функции обратного вызова* могут быть использованы как *алгоритмы* для *решения задач*, имеющих *несколько способов решения*. Одной из таких задач является сортировка. 

Например, в JavaScript метод `Array.prototype.sort(compareFunction)` принимает функцию обратного вызова `compareFunction`, использующуюся как алгоритм сравнения двух элементов массива.
```js
const compareFunction = (a, b) => a - b;
[1, 3, 2].sort(compareFunction); // [1, 2, 3]
```
Аналогично работают методы `find`, `filter` (поиск, фильтрация по заданному алгоритму) и многие другие.

Но чаще всего *функции обратного вызова* используются как какой-то *набор инструкций*, который нужно *выполнить после совершения* какого-то *действия* или *наступления события*. Использование колбэков позволяет убедиться, что код внутри них выполнится не раньше, чем асинхронная функция завершит своё выполнение. 

Именно такой вариант использования колбэков является ключом к асинхронности в NodeJS. 

Сам подход появился в функциональном программировании ещё задолго до появления NodeJS и назывался **Continuation-passing Style** (CPS) и подразумевал, что *управление* (какой-то набор инструкций) *передавалось* далее *в форме продолжения* (continuation). То есть одна функция могла принять другую функцию — **функцию продолжения** (continuation function). По завершению своей работы вместо возвращения стандартного результата она вызывала функцию продолжения, передавая ей результат в качестве аргумента.

Большинство методов NodeJS сейчас использует колбэки. Когда асинхронная, блокирующая операция поступает на вход и запускается, колбэк сохраняется в памяти и его выполнение откладывается, последующий код может продолжить своё выполнение. Как только основной код и асинхронная функция завершают своё выполнение, колбэк достаётся из памяти и выполняетсся в том же потоке, в котором выполнялся основной код. Такой подход весьма эффективен, поскольку значительно увеличивает пропускную способность и скорость NodeJS-приложений.

Пример асинхронной функции `setTimeout(callback, delay)`, принимающей *колбэк*, который вызовется *не ранее*, чем *через* `delay` *миллисекунд*.
```js
setTimeout(() => console.log('Notes'), 300);
// выведется строка 'Notes' не ранее, чем через 300мс
```

### Паттерн error-first callback

Большинство асинхронных методов в *NodeJS* следуют *идиоматическому* (свойственному языку) *паттерну* **Error-first callback** (сперва ошибка), позволяющий довольно просто узнать, произошла ли ошибка при выполнении операции. 

Если паттерн не используется, пользователь самостоятельно должен по аргументам колбэка выяснять, была ли ошибка или нет, что значительно сложнее.

*Идея паттерна* заключается в следующем
* *Функция обратного вызова* *передаётся последним аргументом* в метод, производящий некоторую *асинхронную операцию*.
* Если *операция завершается ошибкой*, *первым аргументом функции обратного вызова* станет *экземпляр* `Error`. 
* Если *операция завершается успешно*, *первым аргументом* станет `null`, а *результат операции* (данные) будет передан *последующими аргументами аргументом* (чаще всего только вторым аргументом).
```js
const asyncFn = (param1, param2, /* ... */, callback) => {
  if (/* error occurs */) {
    return callback(new Error('reason'));
  }
  /* ... */
  const data = { /* ... */ };
  callback(null, data, /* ... */);
}
```
```js
const callback = (err, data, /* ... */) => { /* ... */ };
asyncFn(1, 2, /* ... */, callback);
```

*Обработка ошибок* и *данных* на примере *асинхронного чтения файла*
```js
const fs = require('fs');

const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
    /* обработать ошибку здесь */
  } else {
    console.log(data);
    /* обработать данные здесь */
  }
};

/* асинхронное чтение файла */
fs.readFile('/* ... */', readFileCallback);
```

Попытка выбросить ошибку `err` из функции обратного вызова является распространённой ошибкой, поскольку к моменту вызова `readFileCallback` код вокруг `fs.readFile` завершит своё выполнение. Ошибка не попадёт в `try..catch` и, скорее всего, приведёт к краху всего приложения.
```js
const readFileCallback = (err, data) => {
  if (err) {
    throw err; // так лучше не делать
  } else {
    console.log(data);
  }
};

try {
  fs.readFile('/* ... */', readFileCallback);
} catch (err) {
  /* ошибка сюда не попадёт */
  console.log(err);
}
```
Аналогичная ситуация с данными `data`. Их возврат при помощи `return` ничего не даст. Функция `fs.readFile` просто вызовет операцию чтения, но код не будет ждать её выполнения и пойдёт дальше. Поэтому возвращённое значение будет `undefined`.
```js
const readFileCallback = (err, data) => {
  if (err) {
    console.error('Read file error occured: ', err);
  } else {
    console.log(data);
    return data;
  }
};

const data = fs.readFile('/* ... */', readFileCallback);
console.log(data); // undefined
```

### Callback hell

Как мы уже выяснили, использование кобэков помогает сделать код асинхронным.

<!-- асинхронные операции вызываются, но дальнейший код не ждёт их завершения, продолжая свою работу. В итоге ошибки и данные из функций обратного вызова не могут быть возвращены: их необходимо обрататывать на месте. -->

Операции, которые должны выполниться после асинхронной функции, должны быть переданы в её аргументы колбэком, иначе правильная последовательность выполнения не гарантируется.

Если несколько асинхронных операций должны выполниться последовательно, появляется цепочка (каскад) вложенных колбэков, своеобразное ветвление кода.

Например, асинхронное последовательное создание, чтение, удаление файла выглядит следующим образом.
```js
const fs = require('fs');

fs.writeFile('./input.txt', 'Hello!', 'utf8', (writeErr) => {
  if (writeErr) {
    console.error('White file error occured: ', writeErr);
  } else {
    fs.readFile('./input.txt', 'Hello!', 'utf8', (readErr, data) => {
      if (readErr) {
        console.error('Read file error occured: ', readErr);
      } else {
        console.log(data.toString());
        fs.unlink('./input.txt', (removeError) => {
          if (removeError) {
            console.error('Remove file error occured: ', readErr);
          }
        });
      }
    });
  }
});
```
Такое ветвление называют **Callback Hell**, а в других языках программирования можно встретить аналогичное понятие **Pyramid of doom**. Чем больше последовательных асинхронных операций, тем сложнее работать с таким кодом.

### Способы разрешения Callback Hell

На сегодняшний день эффективным решением проблемы является использование `Promise` и `async..await` 

До их появляения разработчики пытались уменьшить негативное влияние *Callback Hell*, вынося функции обратного вызова в переменные или даже в отдельные модули.

Если вынести функцию не удаётся (например, в неё используются переменные из замыкания), можно использовать именованные функции вместо анонимных. Это особенно может упростить понимание кода, когда асинхронная функция принимает несколько функций обратного вызова.
```js
fs.writeFile('./input.txt', 'Hello!', 'utf8', function writeFileCallback(err) {
  /* ... */
});
```
Использование паттерна *Error-first callback* также помогает бороться с *Callback Hell*: в каждой функции обратного вызова обрабатывается именно свойственная ей ошибка. В противном случае довольно трудно было бы понять, где ошибка возникла.

## Промиссы

Есть *другой способ разрешения Callback Hell*: *промиссификация асинхронных функций* и объединение их в цепочку промиссов (promise chaining). 

Promise не заменяет функции обратного вызова совсем (они всё ещё передаются в `then` и `catch`), но код читать становится намного проще.

Например, промиссифицируем асинхронные функции создания, чтения и удаления файла.
```js
const fs = require('fs');

/* промиссификация вручную */
const writeFile = (filePath, fileData, encoding) => new Promise((resolve, reject) => {
  fs.writeFile(filePath, fileData, encoding, (err, data) => err ? reject(err) : resolve(data));
});

/* промиссификация с помощью promisify */
const promisify = fn => (...args) => new Promise((resolve, reject) => {    
  const callback = (err, data) => err ? reject(err) : resolve(data);
  fn(...args, callback);
});
const readFile = promisify(fs.readFile);
const removeFile = promisify(fs.unlink);
```
```js
writeFile('input.txt', 'Notes', 'utf-8')
  .then(() => readFile('input.txt', 'utf-8');
  .catch(writeErr => console.error('Write file error occured: ', writeErr))
  .then(() => removeFile('input.txt')
  .catch(readErr => console.error('Read file error occured: ', readErr))
  .catch(removeErr => console.error('Remove file error occured: ', readErr));
```

Начиная с Node v11.0.0 можно использовать встроенные промиссы.
```js
const fs = require('fs').promises;

fs.readFile('input.txt')
  .then(() => { /* ... */ })
  .catch(() => { /* ... */ });
```

## async..await

Самым современным способом решения **Callback Hell**, который вообще исключает использование функций обратного вызова, является `async..await`.

Эта конструкция позволяет писать асинхронный код в синхронном стиле, поскольку под капотом оборачивает его в промиссы.

`await` дожидается выполнения промисса или цепочки промиссов (вызывает `.then` до тех пор, пока не вернётся ошибка или примитивное значение). Использование `await` доступно только внутри `async`.

`async` оборачивает результат выполнения функции или метода в промисс. 

```js
const asyncFn = async () => {
  try {
    const data = await readFile('input.txt');
    await removeFile('input.txt');
  } catch (e) {
    console.log(e);
  }
};

asyncFn(); // Promise
```
При использовании `async..await` ошибка или данные так же, как и в случае с функциями обратного вызова, не могут быть возвращены в код, в котором была вызвана функция: в данном случае они не покидают промисс.
```js
const asyncFn = async () => {
  try {
    const data = await readFile('input.txt');
    await removeFile('input.txt');
    return data;
  } catch (e) {
    console.log(e);
    throw e;
  }
};

asyncFn
  .then(data => { /* ... */ })
  .catch(err => { /* ... */ })
```
Ничего глобально не изменилось, код просто стал чище.
