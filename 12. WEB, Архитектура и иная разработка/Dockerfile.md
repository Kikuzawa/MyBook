## Использование образов с помощью FROM

**Инструкция FROM** инициализирует новый этап сборки и устанавливает *базовый образ*, функциональность которого может быть использована в последующих инструкциях. 
```dockerfile
# Dockerfile
FROM ubuntu:latest
```
```dockerfile
# Dockerfile

# образ для NodeJS
FROM node:latest 

# ...

# npm доступен благодаря образу node
RUN npm i 
```

*Валидный Dockerfile* должен *содержать* как минимум *одну инструкцию FROM* и она должна быть *первой инструкцией* в файле.

Для создания базового образа используется инструкция `FROM scratch`.

## Копирование файлов с помощью ADD И COPY

**Инструкция COPY** позволяет скопировать локальный файл или папку с хост-машины в образ. Она принимает два параметра: относительный путь на хост-машине, откуда копировать, и абсолютный путь, по которому данные будут доступны в контейнере.
```dockerfile
# Dockerfile
COPY ./package.json /app/
COPY ./src /app/src
```
**Инструкция ADD** может делать то же самое, но помимо этого она может принять URL как источник для копирования или разархивировать локальный `.tar` файл, а затем поместить в образ.
```dockerfile
# Dockerfile
ADD ./package.json /app/
ADD ./src /app/src

ADD archive.tar.gz /
ADD http://some_url.here /
```

Если нет явной необходимости в ADD, лучше использовать COPY.

## Запуск команд с помощью RUN и CMD

**Инструкция RUN** позволяет запускать команды внутри образа (image). Эти команды запускаются один раз во время сборки (build) и записываются в образ как новый слой (layer).
```dockerfile
# Dockerfile
RUN echo "Install modules"
RUN npm install
```

**Инструкция CMD** описывает *команду по умолчанию*, которая должна *запускаться при запуске готового образа, то есть контейнера*. 
```dockerfile
# Dockerfile
CMD npm start
```
Таким образом, несмотря на то, что CMD является инструкцией Dockerfile, он запускается не во время сборки, а уже в запущенном контейнере. Чаще всего командой в CMD выступает запуск сервера.

## Рабочая директория WORKDIR

**Инструкция WORKDIR** устанавливает *рабочую директорию* для инструкций `RUN`, `CMD`, `COPY`, `ADD`. Все действия, связанные с перечисленными инструкциями, будут происходить в заданной при помощи `WORKDIR` директории.
```dockerfile
# Dockerfile
WORKDIR /app
```
По умолчанию используется `WORKDIR /`.
 
Инструкция `WORKDIR` может быть использована несколько раз.
```dockerfile
WORKDIR /
COPY ./package.json /app/

WORKDIR /app
COPY ./src ./src
```

## Аргументы ARG
**Инструкция ARG** определяет переменную, которую можно передать во время сборки (build-time) контейнера.

* Объявление аргументов в Dockerfile.
```dockerfile
# Dockerfile
ARG argument_name
ARG another_argument_name=default_value # со значением по умолчанию
```
* Использование аргументов в Dockerfile.
```dockerfile
# Dockerfile
RUN echo ${argument_name}
RUN echo ${another_argument_name}
```
* Передача аргументов в команду сборки контейнера.
```cmd
docker-compose build --build-arg port=3000 --build-arg env="local"
```
```dockerfile
# Dockerfile
ARG port
ARG env
```

## Переменные окружения ENV

**Инструкция ENV** сохраняет переменную внутри контейнера. Таким образом переменная в контейнере доступна во время выполнения (run-time).
* Объявление переменных окружения в Dockerfile. 
```dockerfile
# Dockerfile
ENV env=production
```
* Передача в команду запуска контейнера.
```cmd
docker run -e env=production
```

Если есть необходимость передать аргумент как переменную окружения, то можно сделать это следующим образом.
```dockerfile
# Dockerfile
ARG port
ENV port=${port}
```

## Порты и инструкция EXPOSE

Ранее уже отмечалось, *контейнеры* достаточно *изолированы от окружающего мира*, но иногда это *можно контролировать*.

Если *внутри контейнера запущено приложение* на каком-то порте (например, `3000`), то оно будет *доступно только внутри контейнера*. Проверить, что оно действительно запущено в контейнере можно, сделав запрос на URL из консоли контейнера.
```cmd
docker exec -it container_id bash
curl "http://localhost:3000"
```
При этом *у хост-машины нет доступа* к *приложению*, запущенному *в контейнере*.

**Инструкция EXPOSE** используется в целях документации, позволяя явно указать, какие порты используются внутри контейнера.
```Dockerfile
# Dockerfile
FROM node:12.13.1

EXPOSE 3000
```

Если *порт контейнера выставляется наружу*, то он называется **выставленным** (exposed).

Можно также вместо *инструкции EXPOSE* *выставить порт* при помощи *флага* `--expose`.
```cmd
docker run --expose 3000 your_image
```

*Выставление порта* *не* является *обязательным*, поскольку оно *не предоставляет хост-машине доступ к приложению*.

Чтобы *предоставить доступ хост-машине*, необходимо **опубликовать** (publish) *порт*. В таком случае *порт* называют **опубликованным** (published).

При *создании контейнера* у него *по умолчанию* *нет опубликованных портов*. 

Для *публикации порта* используется *флаг* `--publish`, `-p`. Флаг принимает *порт хост-машины* и *порт контейнера* в формате `hostPort:containerPort`.
```cmd
docker run --publish 4000:3000 your_image
```
В примере выше приложение, которое запущено внутри контейнера на порте `3000`, также доступно и на хост-машине на порте `4000` (`http://localhost:4000`).

Можно также *опубликовать* сразу *все выставленные порты контейнера* на *случайные порты хост-машины* при помощи *флага* `--publish-all`, `-P`.
```cmd
docker run --publish-all your_image
```
*Публикация* на *случайные порты* хост-машины *не удобна* из-за трудности конфигурации приложений, которые от этих портов зависят.

*Несколько портов лучше публиковать* следующим образом.
```cmd
docker run -p 3000:3000 -p 3001:3001 your_image
```

## Пример Dockerfile для NodeJS
```Dockerfile
# Dockerfile
FROM node:12.13.1

ARG port
ARG env

EXPOSE ${port}
COPY ./package.json /app/
COPY ./src /app/src

WORKDIR /app

RUN npm install
RUN NODE_ENV=${env} npm run build

CMD npm run start
```
```cmd
docker build --build-arg port=3001 --build-arg env=staging .
```
