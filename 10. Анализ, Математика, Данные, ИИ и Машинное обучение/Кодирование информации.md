# Кодирование информации
- [Кодирование и декодирование](#кодирование-и-декодирование)
- [Набор символов и кодировка](#набор-символов-и-кодировка)
- [Код](#код)
- [Разновидности кодировок](#разновидности-кодировок)
- [О кодировке ASCII](#о-кодировке-ascii)
- [О стандарте Unicode](#о-стандарте-unicode)

## Кодирование и декодирование

**Кодированием** (англ. encoding) называют *процесс преобразования последовательности символов некоторого алфавита* `A` в *последовательность символов другого алфавита* `B`. 

**Декодированием** (англ. decoding) называют *процесс обратного преобразования* из *последовательности символов алфавита* `B` в *последовательность символов алфавита* `A`. 

Фактически, можно рассматривать *кодирование* как *преобразование информации* в *данные*, а *декодирование* как *преобразование данных* в *информацию*.

## Набор символов и кодировка

**Набором символов** (англ. character set, charset) называют некоторый *алфавит*, *символы* которого *могут* быть *использованы* во многих *других алфавитах*.

Например, некоторый *набор символов* может *содержать символы латинского алфавита* `{ ..., a, b, ..., z, ... }`, а *многие* из этих *символов используются* в *английском*, *немецком*, *французском*, *итальянском* и других алфавитах.

**Кодировкой символов** (англ. character encoding) или просто **кодировкой** (англ. encoding) называют *закодированный набор символов*, то есть такую *таблицу*, в которой *каждому символу* из *набора символов* *ставится* в *соответствие последовательность из одного или нескольких символов* некоторого *другого алфавита*. 

Обычно в *кодировке* *каждому символу* из *набора символов* ставится в *соответствие* некоторое *целое число* *аналогично* тому, как *каждому элементу массива* (*коллекции*) ставится в *соответствие* его *индекс*. Это *целое число* обычно *представляют* в *одной* из *трёх форм*:
1) В **десятичной системе счисления** (10 с/с), которая *привычна человеку*.
2) В **двоичной системе счисления** (2 с/с), чтобы показать, *как компьютер видит* данное *число*.
3) В **шестнадцатиричной системе счисления** (16 с/с) для *краткости записи длинных чисел*.

Например, в некотором *закодированном наборе символов* `A` *символу* `'#'` *может соответствовать десятичное число* `124` (в *2 с/с* - `01111100`, в *16 с/с* - `7c`), а *символу* `'$'` - *десятичное число* `255` (в *2 с/с* - `11111111`, в *16 с/с* - `ff`).

*Одному набору символов может соответствовать несколько кодировок*.


<!-- набор символов - коллекция символов -->

## Код
- [О коде](#о-коде)
- [Формальное определение кода и его расширения](#формальное-определение-кода-и-его-расширения)

### О коде

**Кодом** (англ. code) называют некоторый *алгоритм* (*последовательность действий*, *набор инструкций*), который *преобразует символ одного алфавита* `A` в *определённую последовательность символов* другого *алфавита* `B`. 

*Алфавит* `A` называют **исходным алфавитом** (англ. source alphabet), а *алфавит* `B` - **целевым алфавитом** (англ. target alphabet). 

*Если целевой алфавит* `B` *содержит лишь два символа* (*может закодировать лишь два состояния*), то *код* называют **двоичным** или **бинарным кодом** (англ. binary code). Чаще всего *целевой алфавит бинарного кода состоит* из *нуля и единицы*, то есть `B = { 0, 1 }`, что приводит нас к *использованию двоичной системы счисления* (англ. the binary number system).

**Кодом символа** будем называть *закодированное представление* этого *символа*.

### Формальное определение кода и его расширения

Пусть *имеются* *исходный* и *целевой алфавиты* `A` и `B`. Пусть также *имеются бесконечные множества* `A*` и `B*`, являющиеся *множествами всевозможных последовательностей символов алфавитов* `A` и `B` *соответствено*.

**Кодом** называют такую *функцию* (*отображение*) **`c: A → B*`**, которая *преобразует* (англ. map) *каждый символ алфавита* `A` в некоторую *последовательность символов алфавита* `B`. Такая *последовательность однозначно определяется заданным алгоритмом* (*набором символов*).

**Расширением кода `c`** (англ. extension) называют *функцию* **`c*: A* → B*`**, которая *преобразует любую последовательность символов алфавита* `A` в *определённую последовательность символов алфавита* `B`. 

<!--
`f(x) = y`, где `x` - *упорядоченный набор (кортеж) символов алфавита* `A`, а `y` - *упорядоченный набор (кортеж) символов алфавита* `B`. Тогда *пример выше* можно *записать* как `f('a') = 01000001`.
-->

#### Пример кода и его расширения

Пусть *имеется исходный алфавит* `A = { r, s, t }` и *целевой алфавит* `B = { 0, 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9 }`.


По определению, *кодом* является *функция* **`c: A → B*`**, которая *принимает символ алфавита* `A` и *возвращает последовательность символов алфавита* `B` (*десятичное число*) по *заданному правилу*.


Пусть теперь *последовательность символов алфавита* `B` задаётся *кодировкой ANSII*.
Символ | Десятичный код символа
:--: | :--:
r | 162
s | 163
t | 164

В таком случае *справедливо следующее*
```
с('r') = 162,
c('s') = 163,
c('t') = 164,
```
что так же *можно записать*
```
c = { r ↦ 162, s ↦ 163, t ↦ 164 },
```
где `r, s, t ∈ A` и `162, 163, 163 ∈ B*`.

Рассмотрим теперь *расширение кода* в виде *функции* **`c*: A* → B*`**, которая *принимает последовательность символов исходного алфавита* `A` и *преобразует* её в *последовательность символов целевого алфавита* `B` по тому же *правилу*, что и *код* `c: A → B*` .

Например, пусть `ts, ssr ∈ A*`, тогда
```
c* = { ts ↦ 164162, ssr ↦ 16316312 },
```
где `164162, 16316312 ∈ B*`.

<!--
Из примера выше понятно, что для *декодирования* необходимо знать фиксированную длину кода символа, иначе разделить последовательность не получится
Например, можно установить длину = 3, тогда в случае двухзначного числа впереди добавится 0
-->


<!--

Со временем пришли к тому, что 256 символов не достаточно, поэтому в один символ строки теперь выделяют 2-4 байта. Например, выделение 2 байт на один символ позволяет использовать алфавит, содержащий до 2^16 = 65536 символов.
-->


## Разновидности кодировок

- [Однобайтовые кодировки](#однобайтовые-кодировки)
- [Преимущества и недостатки однобайтовых кодировок](#преимущества-и-недостатки-однобайтовых-кодировок)


*Кодировки* можно *разделить* на *несколько типов* в *зависимости* от *затрачиваемой* ими *памяти* на *каждый символ*:  
1) *Фиксированный размер* для *всех символов*. *Кодировки* с *фиксированным размером подразделяются* на *однобайтовые* и *многобайтовые* (обычно, *2-4 байта*).
2) *Динамический размер символа*.

### Однобайтовые кодировки

*Размер представления* любого *символа* в самых *первых кодировках не превышал одного байта*. Наиболее яркими *примерами таких кодировок выступают* **семибитная кодировка ASCII** и **восьмибитная** (*однобайтовая*) **расширенная кодировка ASCII**. *Кодировка ASCII* является *стандартом* в *языке C* и часто *встречается* при работе с языком *C++*.

Используя *формулу* *количества информации* `i` в *одном символе* *алфавита* `A` *мощности* `n`: `i = log2(n)`, *приходим* к тому, что **`n = 2^i`**, откуда *следует*, что **семибитная кодировка** позволяет *закодировать* лишь *набор* из **`2^7 = 128`** *и менее* **символов**, а **однобайтовая кодировка** - *набор* из **`2^8 = 256`** *и менее* **символов**.

Поскольку *минимально адресуемая единица памяти* на *большинстве современных компьютеров* равна *одному байту*, для *двоичного представления символов ASCII* чаще всего используют *8-битные последовательности вместо 7-битных*. Как следствие, *кодировку ASCII* так же можно считать *однобайтовой*.

### Преимущества и недостатки однобайтовых кодировок

*Однобайтовая кодировка* *проста* в *реализации*, *закодированный* с её помощью *текст* имеет *наименьший размер* и этот *размер* можно довольно *просто рассчитать* (`1 символ = 1 байт`). 

*С другой стороны*, *однобайтовая кодировка* сильно *ограничена*, поскольку *такая кодировка* может *вместить* очень *мало языков*. 

*Когда это* может быть *важно*? Например, в *тексте* с *цитатами* из *оригинальных источников* на *иностранных языках*. Если *кодировка не поддерживает* некоторый *язык*, определённые *фрагменты текста* будут *представлять собой* нечто вроде `"Ñ†ÑƒÐ°Ñ‹Ð²"`, что *свидетельствует* о *неправильном декодировании* и что *невозможно разобрать*. *Можно*, конечно, *переключить кодировку*, но тогда уже *другая часть текста станет неразборчивой*. Более того, в *однобайтовую кодировку не вмещаются* даже *все символы китайского языка*.


Как *итог*, *однобайтовая кодировка идеально подходит* для *небольшой локальной системы*, в которой *представление всей информации не выходит* за *пределы ограниченного множества символов*. Когда *две и более* такие *системы* с *различными кодировками* начинают *взаимодействовать друг с другом*, что и *подразумевает* под собой *интернет*, *появляются проблемы*.


Очевидным *решением проблемы* стало *расширение кодировки ASCII*. Так *появилась* **расширенная кодировка ASCII** (англ. Extended ASCII), которая может *закодировать* до `256` *символов*, но и *её* вскоре оказалось *не достаточно* из-за *быстрого развития компьютерных сетей*. Это *привело* к *созданию* **стандарта Unicode**, который *поддерживает* почти *все существующие* в мире *символы*.


<!--
но это *не работает*, когда *две* и более *различные системы взаимодействуют* друг с другом, а именно *такое взаимодействие* и *подразумевает* под собой *интернет*. 
-->

## О кодировке ASCII

**Кодировка ASCII** (англ. American Standard Code for Information Interchange) была *разработана* для *управления средствами обмена информацией* (например, *телетайп*) ещё *до появления компьютера*.

Большинство *современных кодировок обратно совместимы* с *кодировкой ASCII*.

*Кодировка ASCII содержит*:
1) **Управляющие символы** (англ. Control characters). Например, `Backspace`, `Space`, `Delete`, `\n`.
2) **Печатные символы** (англ. Printable characters), *включающие* в себя *строчные* и *прописные буквы латинского алфавита*, *цифры*, *знаки препинания* и некоторые *другие наиболее распространённые символы* (`#`, `&`, `@`, `$`, `=` и *так далее*).

*Каждому символу кодировки ASCII ставится* в *соответствие целое число* (*код символа*) *от* `0` *до* `127`, которое может быть *представлено 7-битной строкой*. 

Тем не менее, поскольку *минимально адресуемая единица памяти* на *большинстве современных компьютеров* равна *одному байту*, для *двоичного представления символов ASCII* чаще всего используют *8-битные последовательности вместо 7-битных*. Для этого в *начало двоичной последовательности* *добавляется один нулевой бит*. Например, *вместо* `1000110` *записывают* `01000110`

*Ниже выборочно представлены символы* и *их коды* в *кодировке ASCII*:
Код символа | Двоичный код символа | Символ
:--: | :--: | :--:
0 | 00000000 | "\0" (Null)
8 | 00001000 | "\b" (Backspace, BS)
9 | 00001001 | "\t" (Horizontal Tab, HT)
10 | 00001010 | "\n" (Line Feed, LF)
13 | 00001101 | "\r" (Carriage Return, CR)
40 | 00100000 | Space
49 | 00110001 | "1"
50 | 00110010 | "2"
57 | 00111001 | "9"
65 | 01000001 | "A"
66 | 01000010 | "B"
90 | 01011010 | "Z"
97 | 01100001 | "a"
98 | 01100010 | "b"
122 | 01111010 | "z"
127 | 01111111 | Delete


## О стандарте Unicode
- [Универсальный набор символов (UCS)](#универсальный-набор-символов-ucs)
- [Форматы Unicode (UTF)](#форматы-unicode-utf)

### Универсальный набор символов (UCS)

В наши дни *самым* широко *используемым набором символов* является **универсальный набор символов** (англ. Universal character set, UCS), *являющийся частью стандарта Unicode*. *Этот набор символов содержит* почти все *зарегистрированные символы мира*, в том числе *символы всех существующих разговорных языков*.

*Благодаря* такой *широкой поддержке символов*, в *одном файле* с *кодировкой* стандарта *Unicode может использоваться сколько угодно языков*. В случае же *использования однобайтовой кодировки*, *пришлось* бы *переключать кодовые страницы* (*кодировки*), чтобы *распознать* (*декодировать*) отдельные *фрагменты текста*.

### Форматы Unicode (UTF)

*Стандарт Unicode предоставляет* целое **семейство кодировок UTF** (англ. Unicode transformation format), *каждая* из *которых* имеет *свой алгоритм кодирования символов* *универсального набора*.

*Символы Unicode представляются целыми неотрицательными числами*, которые обычно *записываются* в *шестнадцатиричной системе счисления* (16 с/с) для *компактности*.

*Основными



<!--
позволяющих *ограничить диапазон используемых символов набора* (*уменшить количество символов* в *наборе*) и таким образом *уменьшить затраты памяти* на *один символ*.
-->










