# Строковый тип
- [О строковом типе](#о-строковом-типе)
- [Обозначение строки](#обозначение-строки)
- [Операции над строками](#операции-над-строками)
- [Сравнение строк](#сравнение-строк)
- [Представление строк в памяти компьютера](#представление-строк-в-памяти-компьютера)
- [Размер строки](#размер-строки)


## О строковом типе

**Строковым типом** (англ. String) называют *тип данных*, *каждое значение* которого *представляет* собой *последовательность символов* некоторого *алфавита*. 

*Значение строкового типа* называют **строкой** (англ. string). 

<!-- *Строка* *представляет* собой *упорядоченный набор элементов с повторениями*. -->

*Количество символов строки* называют **длиной строки** (англ. string length).

## Обозначение строки

В *программном коде значения строкового типа* (*строки*) обычно *заключаются* в *кавычки*:
1) **Одинарные**: `'Мартин Иден'`, `'evergreen'`.
2) **Двойные**: `"Унесённые ветром"`, `"inhale"`.
3) **Косые**: \``Триумфальная арка`\`, \``Round Robin`\`.


## Операции над строками

*Над строками* можно *выполнять* следующие *операции*:
* *Вычисление длины* строки. Например, `("Notes").length --> 5`.
* *Получение символа* из строки по *индексу*. Например, `("Notes").find("t") --> 2`.
* *Конкатенация* (*сложение*) *строк*. Например, `"No" + "tes" --> "Notes"`.
* *[Сравнение](#сравнение-строк)* двух *строк*. Например, `"No" == "tes" --> false`.
* *Поиск подстроки* в строке. Например, `("Notes").includes("tes") --> true`.
* *Замена подстроки* в строке. Например, `("Notes").replace("es", "ion") --> "Notion"`.

В *большинстве языков программирования* *данные операции над строками встроены по умолчанию* или же их *можно подключить вместе* с *библиотекой*.

## Сравнение строк

В *программировании* символы `<`, `<=`, `==`, `>=`, `>` *представляют* собой *операторы* (не *отношения*, как в *теории множеств*), которые *являются частью операций сравнения*. 

*Операция сравнения* является *бинарной операцией*, которая *принимает два операнда любого типа* и *возвращает результат логического типа*, называемый *результатом сравнения*.

*Сравнение строк производится* в *лексикографическом порядке* (*посимвольно*), то есть *символы двух строк сравниваются попарно* по их *числовым кодам*. *Коды символов* *задаются кодировкой*. 

*Больше* считается *та строка*, чей *код символа оказался больше* на *некотором шаге алгоритма сравнения*.

Например, `"music" > "museum"`, поскольку *код символа* `'i'` *больше кода символа* `'e'`. Ниже представлена *таблица* для *наглядности сравнения сравнения*. *Коды символов* взяты из *кодировки ASCII*.

Индекс символа | Символ первой строки | Символ второй строки | Сравнение кодов символов
:--: | :-: | :--: | :-:
0 | `'m'` | `'m'` | `109` = `109`
1 | `'u'` | `'u'` | `117` = `117`
2 | `'s'` | `'s'` | `115` = `115`
3 | `'e'` | `'i'` | `101` < `105`
4 | `'u'` | `'c'` | 
5 | `'m'` |   | 

Аналогично, `"музыка" > "музей"` (`'ы' > 'е'`), `”волк < "тигр"` (`'в' < 'т'`), `"близнец" = "близнец"`.

### Алгоритм сравнения строк

Пусть *сравниваются две строки* `a` и `b`.

Если *хотя бы одна* из *строк* `a` и `b` *пуста*, то *результат сравнения* можно *определить сразу*:
1) Если *обе строки пусты*, то `a = b`.
2) Если *одна строка пуста*, то *больше непустая строка*.

*Далее считаем*, что `a` и `b` *не пусты*.

Сначала берётся *код первого символа строки* `a`, *код первого символа строки* `b` и *осуществляется их сравнение*:
  * Если *код символа строки* `a` *больше кода символа строки* `b`, то `a > b`. 
  * Если *код символа строки* `a` *меньше кода символа строки* `b`, то `a < b`.
  * Если *коды символов совпали*, то *выполнение алгоритма продолжается*.
  * Если *достигнут конец* хотя бы *одной строки*, то *сравнение заканчивается*:
    * Если *все предыдущие символы совпали* и *длины строк* `a` и `b` *совпадают*, то `a = b`.
    * Если *все предыдущие символы совпали* и *длины строк* `a` и `b` *не совпадают*, то *больше та строка*, в *которой больше символов*.
  * *Берётся код следующего символа* из *каждой строки* и *выполнение алгоритма начинается сначала*.

## Представление строк в памяти компьютера

<!-- перенести в programming -->

Существует *два способа представить строку* в *памяти компьютера*:  
* *[Массив символов](#массив-символов)*.
* *[Нуль-терминированная строка](#нуль-терминированная-строка)*.

### Массив символов

**Массивом символов** называют *способ представления* **строки длины `n`** в *памяти компьютера* как **массива** из **`n + 1` элементов**, в котором *символы строки* занимают *индексы массива от* `1` *до* `n`, а *элемент* с *нулевым индексом хранит длину строки* (*количество символов*) или *размер строки* (*количество байт*).

<!--
Например, можно представить слово `Notes` как \u004e\u006f\u0074\u0065\u0073
 Символ (код символа)
-->

*Представление строки* `"Notes"` *массивом символов*:
Индексы элементов массива | 0 (длина строки) | 1 | 2 | 3 | 4 | 5
:--: | :--: | :--: | :--: | :--: | :--: | :--:
Элементы массива | 5 | `'N'` | `'o'` | `'t'` | `'e'` | `'s'`

<!--
Элементы массива, строка `"море"` | 4 | `'м'` | `'о'` | `'р'` | `'е'` | -
-->

### Нуль-терминированная строка

**Нуль-терминированной строкой** называют *способ представления строки* в *памяти компьютера*, при котором *строка представляется непрерывной последовательностью байт*, которая *оканчивается специальным* *нуль-символом* (*признаком конца строки*, *завершающим байтом*). 

**Нуль-символ** *представляет* собой *любой символ алфавита*, который был *выбран* в *качестве признака конца строки*. Например, в *алфавите ANSI* *нуль-символом выступает символ* `NUL`, имеющий *код* `0`.

Если *выделяется один байт на один символ алфавита*, то *нуль-терминированная строка* из **`n` символов** *занимает* **`n + 1` байт**.

*Нуль-терминированные строки* являются *стандартом* в *языке C*, поэтому их *иногда называют* **C-строками**.

## Размер строки

**Размер строки** зависит от *длины* этой *строки* (*количества символов* в ней), от *размера одного символа* (*размер задаётся кодировкой*) и от *способа представления строки* в *памяти компьютера* (например, если *строка* *нуль-терминированная*, то её общий *размер увеличивается на один байт*).

Например, при *использовании однобайтовой кодировки ASCII* *нуль-терминировання строка* `"Notes"` *займёт* `5 + 1 = 6 байт`. Кстати говоря, *столько же* вышло бы при *использовании* *кодировки UTF-8*, поскольку она *обратно совместима* с *кодировкой ASCII*


Например, при *использовании кодировки UTF-8* *нуль-терминированная строка* `"Роза"` *займёт* `4 • 2 + 1 = 9 байт`, поскольку *каждый символ кириллицы* в *кодировке UTF-8 представляется двумя байтами*.

*Представление нуль-терминированной строки* `"Notes"` *последовательностью байт*, *записанных* в *шестнадцатиричной системе счисления*:
```
0x4e 0x6f 0x74 0x65 0x73 0x00
N    o    t    e    s    NUL
```
