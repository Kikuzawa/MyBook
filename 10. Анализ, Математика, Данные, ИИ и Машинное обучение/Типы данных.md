***«Типом данных*** называют *множество допустимых значений* и *совокупность операций* над этими *значениями*. *Типы данных* позволяют *разбить разнородную информацию* на *несколько заданных типов* (строковый, числовой, логический, дата и другие типы). К *каждому типу* может *применяться* лишь *ограниченное множество операций* (например, *разность чисел*, *конкатенация строк* и так далее)*»*.

# О типе данных
*Рекомендуется* прочитать: [Множество (дискретная математика)]().

**Типом данных** (англ. data type) или просто **типом** (англ. type) называют *множество* (*допустимых*) *значений* и *совокупность операций* над этими *значениями*.

*Компьютер не видит разницы между числом*, *строкой*, *датой* - для него *всё* это лишь *последовательности нулей и единиц*. 

*Тип данных* подсказывает *компьютеру*, как *следует обращаться* с этими *данными*, *предоставляя* (*ограничивая*) *операции* для *работы* с *данными* этого *типа*. Например, *поиск подстроки* для *строковых значений*, *умножение* для *числовых значений*, *логические операции* над *логическими значениями* и так далее.

# Примитивные типы данных

*Большинство языков программирования поддерживает* **3 основных типа данных**:  
1) **[[Логический тип]]**. Содержит *логическое значение*: *истина* или *ложь*. Например, `true` или `false`, `1` или `0`, `да` или `нет`.  
2) **[[Строковый тип]]**. Содержит *текст*. Например, `'По ту сторону изгороди'`, `"письма незнакомке"`.  
3) **[[Числовой тип]]**. Содержит *число*. Например, `7`, `-3`, `3.14`.

*Эти типы данных* также *называют* **примитивными** или **базовыми типами**.

# Символьный тип

**Символьным типом** (англ. Char) называют *тип данных*, *каждое значение* которого *представляет* собой *один* **символ** (англ. character) некоторого *алфавита* (некоторой *кодировки*).

Например, *значениями символьного типа* являются: `'%'`, `'g'`, `'/'`.

*Значение символьного типа занимает столько памяти*, *сколько* должен занимать *символ соответствующей кодировки* . Например, для *ANSII* это всегда `1 байт`, для *кодировок семейства UTF размер варьируется от* `1` *до* `4 байт`.

Например, в *языке C нет строкового типа*, поэтому *строки рассматриваются* в нём как *массивы символов* (`char[]` или `char*`).

# Целочисленный тип
## О целочисленном типе

**Целочисленным типом** (англ. Integer, Integral data type, Int) называют *тип данных*, *каждое значение* которого *представляет* некоторое *число* из *множества целых чисел* `Z`.

*Значение целочисленного типа* называют **целочисленным значением** или **целым числом**.

Например, *целочисленным значениями* являются: `17`, `-3`, `0`.

## Беззнаковые целые числа и целые числа со знаком

В *программировании целые числа подразделяют* на *беззнаковые целые числа* и *целые числа со знаком*

**Беззнаковое целое число** (англ. unsigned integer) *представляет* только *неотрицательные целые числа*:  
`0, 1, 2, 3, ...`.

**Целым числом со знаком** (англ. signed integer) *представляюет любое целое число* (*положительное*, *отрицательное* или *ноль*). Например, `-37`, `8`, `0`.


## Представление целого числа в памяти компьютера

*Математическое множество целых чисел* `Z`, вообще говоря, *бесконечно*. При этом *ресурсы компьютера ограничены*. *Компьютер не способен хранить* что-либо *бесконечное*, поэтому *представление множества целых чисел* в *компьютере ограничивается сверху* и *снизу максимальным* и *минимальным значениями*. 

*Целое число представляется* в *памяти компьютера* *последовательностью байт* (*бит*).

**Длиной целочисленного значения** (англ. integer width, precision) называют *количество бит* в его *двоичном представлении*.

## Кодирование целых чисел
- [[Кодирование беззнаковых целых чисел]]
- [[Кодирование целых чисел со знаком]]

## Размер целого, короткое и длинное целые

<!--
В зависимости от *количества байт*, используемых на *представление целого числа*, выделяют *несколько типов целочисленных значений*. 

Для удобства использования вводятся также короткое целое и длинное целое.
-->

*Размер целочисленного значения задаётся* либо *языком программирования*, либо *зависит* от *размера машинного слова*, который *определяется* *архитектурой процессора* (CPU).

*Ранее* было *показано*, что от *размера целочисленного значения* (`int`) *напрямую зависят диапазоны допустимых знаковых и беззнаковых целых чисел*.

#### Диапазон целых чисел в зависимости от размера целочисленного значения
Размер целого | Беззнаковое целое | Знаковое целое
:--: | :--: | :--:
`1 байт` | *от* `0` *до* `2^8 - 1 = 255` | *от* `-2^7 = -128` *до* `2^7 - 1 = 127`
`2 байта` | *от* `0` *до* `2^16 -1 = 65535` | *от* `-2^15 = -32768` *до* `2^15 - 1 = 32767`
`4 байта` | *от* `0` *до* `2^32 - 1 = 4294967295` | *от* `-2^31 = -2147483648` *до* `2^31 - 1 = 2147483647`
`8 байт` | *от* `0` *до* `2^64 - 1 = 18446744073709551615` | *от* `-2^63 = -9223372036854775808` *до* `2^63 - 1 = 9223372036854775807`


**Коротким целым** (англ. short integer) называют *тип данных*, *предназначенный* для *представления целых чисел*, *размер* которых *меньше либо равен стандартному размеру целочисленного значения* (`int`). *Этот тип* данных может быть *использован* для *экономии памяти*.

**Длинным целым** (англ. long integer) называют *тип данных*, *предназначенный* для *представления целых чисел*, *размер* которых *равен или превышает стандартный размер целочисленного значения* (`int`). *Этот тип* данных *используется* при *работе* с *большими целыми числами*.

В *различных языках программирования размеры короткого* и *длинного целого отличаются*, что можно увидеть на *таблице ниже*.

#### Размеры короткого и длинного целых чисел в различных языках программирования
Язык программирования | Размер короткого целого (`short`) | Размер целого (`int`) | Размер длинного целого (`long`)
:--: | :--: | :--: | :--:
**C** | `2 байта` | `4 байта` | `4 байта`
**C++** | `2 байта` | `4 байта` | `4 байта`
**C#** | `2 байта` | `4 байта` | `8 байт`
**Java** | `2 байта` | `4 байта` | `8 байт`


Пример с JavaScript: Max_value, max safe int, big int

### Сводная таблица
Тип | Размер  | Диапазон допустимых значений
:--: | :--: | :--:
**Ниббл** (англ. **nibble**), **полуоктет** (англ. **semioctet**) | `половина байта` (`4 бит`) | *Беззнаковый*: *от* `0` *до* `2^4 - 1 = 15`, *знаковый*: *от* `-2^3 = -8` до `2^3 - 1 = 7`
**Байт** (англ. **byte**),  **октет** (англ. **octet**) | `1 байт` (`8 бит`) | *Беззнаковый*: *от* `0` *до* `2^8 - 1 = 255`, *знаковый*: *от* `-2^7 = -128` до `2^7 - 1 = 127`
**Короткое целое** (англ. **short**), **полуслово** (англ. **halfword**) | `2 байта` (`16 бит`) | *Беззнаковый*: *от* `0` *до* `2^16 - 1 = 65535`, *знаковый*: *от* `-2^15 = -32768` до `2^15 - 1 = 32767`
**Целое** (англ. int), **слово** (англ. **word**) | `4 байта` (`32 бит`) | *Беззнаковый*: *от* `0` *до* `2^32 - 1`, *знаковый*: *от* `-2^31` до `2^31 - 1`
**Длинное целое** (англ. **long**), **длинное слово** (англ. **longword**),  **двойное слово** (англ. **doubleword**), (англ. **long long**) | `8 байт` (`64 бит`) | *Беззнаковый*: *от* `0` *до* `2^64 - 1`, *знаковый*: *от* `-2^63` до `2^63 - 1`


## Арифметические операции над целыми числами
- [Унарные арифметические операции](#унарные-арифметические-операции)
- [Бинарные арифметические операции](#бинарные-арифметические-операции)

### Унарные арифметические операции
* **Инкремент** (англ. **inc**rement) - *увеличение значения на единицу*. *Обозначение инкремента числа* `x`: `x++` или `++x`. Например, `++6 = 7`.
* **Декремент** (англ. **dec**rement) - *увеличение значения на единицу*. *Обозначение инкремента числа* `x`: `x--` или `--x`. Например, `--4 = 3`.
* **Модуль** (англ. **abs**olute value) - *значение числа без* учёта *знака*. *Обозначение модуля числа* `x`: `|x|` (мат.), `abs(x)` (прог.). Например, `|-5| = 5`.
* **Отрицание** (англ. **neg**ation) - *смена знака числа* на *противоположный*. *Обозначение отрицания числа* `x`: `-x`, `neg(x)` (прог.). Например, *отрицание числа* `8`: `-8`, *отрицание числа* `-2`: `2`.
* **Взятие квадратного корня** (англ. **sq**uare **r**oo**t**). *Обозначение квадратного корня числа* `x`: `√x` (мат.), `sqrt(x)` (прог.). Например, `√49 = 7`, то есть `7 • 7 = 49`.
* **Натуральный логарифм** (англ. **log**arithm). *Обозначение натурального логарифма числа* `x`: `ln(x)`, `log(x)` (прог.). Например, `ln(7) = 1.94591`, то есть `e^(1.94591) = 7`.


### Бинарные арифметические операции
* **Сложение** (англ. **add**ition). *Обозначение сложения чисел* `x` и `y`: `x + y`. Например, `7 + 6 = 13`.
* **Разность** (англ. **sub**traction). ). *Обозначение вычитания числа* `y` из *числа* `x`: `x - y`. Например, `7 - 6 = 1`.
* **Умножение** (англ. **mul**tiplication). *Обозначение умножения чисел* `x` и `y`: `x • y` (мат.), `x * y` (прог.). Например, `6 • 7 = 42`.
* **Деление** (англ. **div**ision). *Обозначение деления числа* `x` на *число* `y`: `x ÷ y` (мат.), `x / y` (прог.). Например, `42 ÷ 6 = 7`.
* **Возведение в степень** (англ. **pow**er). *Обозначение возведения числа* `x` в *степень* `y`: `x ^ y` (мат.), `x ** y` (прог.), `pow(x, y)` (прог.). Например, `2 ^ 4 = 16`.

## Битовые операции над целыми числами
- [О битовых операциях](#о-битовых-операциях)
- [Различие битовых и логических операций](#различие-битовых-и-логических-операций)
- [Унарные битовые операции](#унарные-битовые-операции)
- [Бинарные битовые операции](#бинарные-битовые-операции)
- [Битовые сдвиги](#битовые-сдвиги)

### О битовых операциях

**Битовые**, **побитовые операции** (англ. bitwise operation), **поразрядные операции** *предназначены* для работы с *последовательностями бит*.

Поскольку *целое число* можно *представить* в *двоичной системе счисления* (как *двоичное число*), к нему *применимы битовые операции*.

*Первый бит двоичной последовательности* называют **старшим битом**, *последний бит* - **младшим битом**. 

*Старший* и *младший биты* называют **крайними битами**, *оставшиеся биты последовательности* называют **средними битами**.

### Различие битовых и логических операций

**Логические операции** *принимают операнды логического типа* (или *операнды приводятся* к *данному типу*) и *возвращают результат логического типа*.

В *большинстве языков программирования логические значения представлены значениями* `true` и `false` (иногда `1` и `0`).

```js
0 && 1 = false /* false && true */
3 && 2 = true /* true && true */
```

**Битовые операции** *принимают* в качестве *операндов последовательности бит* (или *значения другого типа приводятся* к *последовательностям бит*) и *возвращают последовательность бит*.

```js
0 & 1 = 0
3 & 2 = 0010 /* 0011 & 0010 */
01100011 & 11110000 = 01100000
```

### Унарные битовые операции
* **Битовое отрицание**, **битовое “НЕ"** (англ. bitwise “NOT”), **дополнение** (англ. complement) *принимает двоичную последовательность* и производит *логическое отрицание каждого* её *бита*, то есть *каждый ноль становится единицей* и *каждая единица становится нулём*. *Обозначение побитового отрицания последовательности* `x`: `NOT x`. 

Выражение | Значение # 1 | Значение # 2 | Значение # 3
:--: | :--: | :--: | :--:
`x` | 00000001 | 10111010 | 11111111
`NOT x` | 11111110 | 01000101 | 00000000

* **Получение знака** *целого числа со знаком*. *Знак определяется* *старшим битом*: `0` - `+`, `1` - `-`.

Число | Знак
:--: | :--:
00000001 | +
10111010 | -
11111111 | -

* **Получение чётности** *целого числа*. *Чётность определяется младшим битом*: `0` - *чётное*, `1` - *нечётное*.

Число | Чётность
:--: | :--:
00000001 | нечётное
10111010 | чётное
11111111 | нечётное

### Бинарные битовые операции
* **Битовое “И”** (англ. bitwise “AND”) *принимает две двоичные последовательности* и производит *логическое “И”* над *каждой парой бит*, которые *стоят* на *одинаковых позициях* в *последовательностях*. *Обозначение битового “И”* для *последовательностей* `x` и `y`: `x AND y`.

Выражение | Значение # 1 | Значение # 2 | Значение # 3
:--: | :--: | :--: | :--:
`x` | 10000001 | 10101010 | 11110001
`y` | 00000111 | 01010101 | 00010000
`x AND y` | 00000001 | 00000000 | 00010000

* **Битовое “ИЛИ”** (англ. bitwise “OR”) *принимает две двоичные последовательности* и производит *логическое “ИЛИ”* над *каждой парой бит*, которые *стоят* на *одинаковых позициях* в *последовательностях*. *Обозначение битового “ИЛИ”* для *последовательностей* `x` и `y`: `x OR y`.

Выражение | Значение # 1 | Значение # 2 | Значение # 3
:--: | :--: | :--: | :--:
`x` | 10000001 | 10101010 | 11110001
`y` | 00000111 | 01010101 | 00010000
`x OR y` | 10000111 | 11111111 | 11110001

* **Битовое “ИЛИ-НЕ”**, **битовое исключающее “ИЛИ”** (англ. bitwise exclusive “OR”, bitwise XOR) *принимает две двоичные последовательности* и производит *логическое исключающее “ИЛИ”* над *каждой парой бит*, которые *стоят* на *одинаковых позициях* в *последовательностях*. *Обозначение битового исключающего “ИЛИ”* для *последовательностей* `x` и `y`: `x XOR y`.

Выражение | Значение # 1 | Значение # 2 | Значение # 3
:--: | :--: | :--: | :--:
`x` | 10000001 | 10101010 | 11110001
`y` | 00000111 | 01010101 | 00010000
`x XOR y` | 01111001 | 00000000 | 00011110

#### Сводная таблица битовых операций
Выражение | Значение # 1 | Значение # 2 | Значение # 3
:--: | :--: | :--: | :--:
`x` | 10000001 | 10101010 | 11110001
`y` | 00000111 | 01010101 | 00010000
`NOT x` | 01111110 | 01010101 | 00001110
`NOT y` | 11111000 | 10101010 | 11101111
`x AND y` | 00000001 | 00000000 | 00010000
`x OR y` | 10000111 | 11111111 | 11110001
`x XOR y` | 01111001 | 00000000 | 00011110


### Битовые сдвиги

**Битовым сдвигом** (англ. bit shift) называют *битовую операцию*, которая *принимает двоичную последовательность* и *смещает биты* (*позиции бит*) в ней.

<!--
Различают *несколько видов сдвигов*.
-->

#### Сдвиги по *направлению смещения бит*
* **Битовый сдвиг влево** (англ. left bitwise shift), *сдвиг* от *младшего бита* к *старшему*, подразумевает *смещение* (*перестановку*) *кадого* из *значений средних бит* на *1 бит влево*.
* **Битовый сдвиг вправо** (англ. right bitwise shift), *сдвиг* от *старшего бита* к *младшему*, подразумевает *смещение* *кадого* из *значений средних бит* на *1 бит вправо*.

#### Сдвиги по *поведению крайних бит*
* При **логическом сдвиге** (англ. logical shift) *один* из *крайних битов выпадает* из *последовательности*, *другой принимает нулевое значение*. 
```
>> 10001111 = 01000111
>> 01000111 = 00100011

<< 10001111 = 00011110
<< 00011110 = 00111100
```
* При **арифметическом сдвиге** (англ. arithmetic shift) *сохраняется знак числа*, который *хранится* в *старшем бите* (*сохраняется значение старшего бита*). В *остальном арифметический сдвиг аналогичен логическому*.
```
>> 10001111 = 11000111
>> 11000111 = 11100011

>> 01000111 = 00100011

<< 10001111 = 00011110
<< 00011110 = 00111100
```
* При **циклическом сдвиге** (англ. circular shift, bitwise rotation) *значение одного крайнего бита переносится* в *другой крайний бит*, то есть *производится [круговая перестановка]()*.
```
>> 10001111 = 11000111
>> 11000111 = 11100011
>> 11100011 = 11110001

<< 10001111 = 00011111
<< 00011111 = 00111110
<< 00111110 = 01111100
```

*Логический сдвиг влево эквивалентен умножению беззнакового целого* на *два*, а *логический сдвиг вправо* - *делению беззнакового целого* на *два*.

*Арифметический сдвиг влево эквивалентен умножению целых чисел* со *знаком* на *два*, а *арифметический сдвиг вправо* - *делению целых чисел* со *знаком* на *два*. 



## Число с плавающей точкой
- [[Экспоненциальная форма записи числа]]
- [О числе с плавающей точкой](#о-числе-с-плавающей-точкой)
- [Операции над числами с плавающей точкой](#операции-над-числами-с-плавающей-точкой)
- [Точность](#точность)
### О числе с плавающей точкой

**Числом с плавающей точкой** (англ. floating-point number) или **числом с плавающей запятой** называют *представление числа* в *экспоненциальной форме записи*.

*Числом с плавающей точкой* можно *представить* как *любое целое число* (например, `371 = 3.71 • 10^2`), так и *любую десятичную дробь* (например, `0.0333 = 3.33 • 10^(-2)`).

*Название числа с плавающей точкой объясняется* тем, что *точку можно поставить где угодно между цифр во внутреннем представлении*. Например, *число* `1984` *можно представить* как `0,1984 • 10^4`, `1,984 • 10^3`, `1984 * 10^0`, `19840 * 10^(-1)` и так далее. 

*Пример выше показывает*, что *существует бесконечное множество представлений числа* как *числа с плавающей точкой*. 

В *программировании* для *представления слишком больших* или *слишком малых* *чисел с плавающей точкой* используют *научную форму записи*, *остальные числа с плавающей точкой записываются* как обыкновенная *десятичная дробь* (*порядок не указывается*).
Число | Научная форма записи | Компьютерное представление числом с плавающей точкой
:--: | :--: | :--:
`7` | `7 • 10^0` | `7.0`
`-322` | `-3.22 • 10^2` | `-322.0`
`19.84` | `1.984 • 10` | `19.84`
`0.000000001` | `1 • 10^(-9)` | `1E-09`
`-0.0000000000177` | `-1.77 • 10^(-11)` | `-1.77E-11`
`300000000` | `3 • 10^8` | `3E+08`

Часто *языки программирования* предоставляют *несколько типов данных*, *каждый* из которых используется для *целых чисел с плавающей точкой*. *Обычно* такими являются *типы данных* `Float` и `Double`, 

### Операции над числами с плавающей точкой
- [О сложении и разности чисел с плавающей точкой](#о-сложении-и-разности-чисел-с-плавающей-точкой)
- [Сложение чисел с плавающей точкой](#сложение-чисел-с-плавающей-точкой)
- [Разность чисел с плавающей точкой](#разность-чисел-с-плавающей-точкой)
- [Умножение чисел с плавающей точкой](#умножение-чисел-с-плавающей-точкой)
- [Деление чисел с плавающей точкой](#деление-чисел-с-плавающей-точкой)


Для *чисел с плавающей точкой* доступны *базовые бинарные арифметические операции*:


*Далее* будем рассматривать *операции над числами* **`x = m1 • 10^e1`** и **`y = m2 • 10^e2`**.

#### О сложении и разности чисел с плавающей точкой

*Сложение* и *разность чисел с плавающей точкой требуют совпадения порядков* чисел: **`e = e1 = e2`**. Если *порядки не совпадают*, то *необходимо перенести точку* в одной из *мажорант* `m1` и `m2` так, чтобы *порядки* `e1` и `e2` *совпали*.

Например, если `x = 3 • 10^2` и `y = 2 • 10^3`, то перед *сложением* или *разностью* `x` и `y` *необходимо*
* *либо* `x` *привести* к *форме* `x = 0.3 • 10^3`,
* *либо* `y` *привести* к *форме* `y = 20 • 10^2`.

#### Сложение чисел с плавающей точкой

**Сложение** (англ. addition) **чисел с плавающей точкой `x` и `y`** осуществляется по *формуле*:  
**`x + y = (m1 + m2) • 10^e`**.

*Ниже* представлено *сложение чисел* `2.5 • 10^5` и `3.25 • 10^6`.
```js
2.5 • 10^5 + 3.25 • 10^6 = 
2.5 • 10^5 + 32.5 • 10^5 =
(2.5 + 32.5) • 10^5 =
36.0 • 10^5 =
3.6 • 10^6 /* инженерная форма */
```

#### Разность чисел с плавающей точкой


**Разность** (англ. subtraction) **чисел с плавающей точкой `x` и `y`** осуществляется по *формуле*:  
**`x - y = (m1 - m2) • 10^e`**.

*Ниже* представлена *разность чисел* `3.5 • 10^3` и `4.5 • 10^2`.
```js
3.5 • 10^3 - 4.5 • 10^2 = 
35 • 10^2 - 4.5 • 10^2 =
(35 - 4.5) • 10^2 =
30.5 • 10^2 =
3.05 • 10^3 /* инженерная форма */
```

#### Умножение чисел с плавающей точкой


**Умножение** (англ. multiplication) **чисел с плавающей точкой `x` и `y`** осуществляется по *формуле*:  
**`x • y = (m1 • m2) • 10^(e1 + e2)`**.

*Ниже* представлено *умножение чисел* `7.25 • 10^3` и `3.0 • 10^2`.
```js
(7.25 • 10^3) • (3.0 • 10^2) = 
(7.25 • 3.0) • 10^(3 + 2) =
21.75 • 10^5 =
2.175 • 10^6 /* инженерная форма */
```

#### Деление чисел с плавающей точкой


**Деление** (англ. division) **чисел с плавающей точкой `x` и `y`** осуществляется по *формуле*:  
**`x ÷ y = (m1 ÷ m2) • 10^(e1 - e2)`**.

*Ниже* представлено *деление чисел* `26.4 • 10^8` и `2.4 • 10^6`.
```js
(26.4 • 10^8) ÷ (2.4 • 10^6) = 
(26.4 ÷ 2.4) • 10^(8 - 6) =
11 • 10^2 =
1.1 • 10^3 /* инженерная форма */
```

### Точность

Иногда появляется необходимость *округлить действительное число*.

Например, *число* `0.16738` может быть *математически округлено до* `0.0`, `0.2`, `0.17`, `0.167` или `0.1674`.

*Округляемое число* называют **истинным значением** (англ. true value) или **действительным**  (*фактическим*) **значением** (англ. actual value).

*Результат округления* называют **измеренным значением** (англ. measured value).

Из *примера выше* следует, что *вместо истинного значения* `0.16738` может быть *использовано одно* из *измеренных значений* `0.0`, `0.2`, `0.17`, `0.167`, `0.1674` в *зависимости* от *требуемой точности*.

**Точностью вычислений** (англ. accuracy) `a` называют *меру близости измеренного значения* `x1` к *истинному значению* `x`. Обычно эта *мера выражается разницей между значениями* `x` и `x1`, *представленной* их *модулем разности*:  
`a = |x - x1|`.

**Точностью** (англ. precision) `p` называют *меру разброса измеренных значений*. Например, для *измеренных значений* `x1` и `x2` она *выражается модулем разности* этих *значений*: `p = |x1 - x2|`·

*Несмотря* на *похожесть формул*, *точность* `p` и *точность вычислений* `a` имеют *существенное различие*, выраженное в их *предназначении*: `a` *вычисляется* для *проверки точности промежуточного* или *конечного результата*, а `p` *задаётся* для *ограничения области допустимых значений*.


<!--
## Ссылка и указатель
- [Ссылка](#ссылка)
-->

## [[Ссылка]]

## [[Указатель]]