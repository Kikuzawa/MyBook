Стандарт [ГОСТ Р 34.11. Информационная технология. Криптографическая защита информации. Функция хэширования](https://docs.cntd.ru/document/1200095035)

Подробнее
- [https://habr.com/ru/articles/188152/](https://habr.com/ru/articles/188152/)
- С кодом (С): [https://xakep.ru/2016/07/20/hash-gost-34-11-2012/](https://xakep.ru/2016/07/20/hash-gost-34-11-2012/)

Пример реализации (C): [https://github.com/okazymyrov/stribog](https://github.com/okazymyrov/stribog)

Включающее две функции
- Функцию с длиной выходного значения в 256 бит
- функцию с длиной выходного значения в 512 бит.

### Преобразования

#### 1. X-преобразование

На вход функции ```X``` подаются две последовательности длиной 512 бит каждая, выходом функции является XOR этих последовательностей

$$
X[k]: V_{512} \to V_{512}\\
X[k](a) = k \oplus a, k,a \in V_512
$$

#### 2. S-преобразование

Функция ```S``` является обычной функцией подстановки. Каждый байт из 512-битной входной последовательности заменяется соответствующим байтом из таблицы подстановок $\pi$



$$
S: V_{512} \to V_{512}\\
S(a) = S(a_{63}||...||a_{0}) = \pi(a_{63})||...||\pi(a_{0})
$$

Таблица $\pi$ является константой

#### 3. P-преобразование

Функция перестановки. Для каждой пары байт из входной последовательности происходит замена одного байта другим.

$$
P: V_{512} \to V_{512}\\
P(a) = P(a_{63}||...||a_{0}) = a_{\tau(63)}||...||a_{\tau(0)}
$$

Таблица перестановок $\tau$ также является константой

#### 4. L-преобразование

Представляет собой умножение 64-битного входного вектора на бинарную матрицу **A** размерами 64x64.

$$
L: V_{512} \to V_{512}\\
L(a) = L(a_{7}||...||a_{0}) = l(a_{7})||...||l(a_{0})
$$

Матрицу **A** можно представить как массив 64-битных слов


### Функция сжатия

![[Pasted image 20241009163124.png]]

**m** — очередной блок исходного сообщения, **h** — значение предыдущей функции сжатия

#### Функция $g_n$

Пусть h, N и m — 512-битные последовательности

Алгоритм вычисления $g(N,h,m):

1. Вычислить значение $K = h \oplus N$
1. Присвоить значение $K = S(K)$
1. Присвоить значение $K = P(K)$
1. Присвоить значение $K = L(K)$
1. Вычислить $t = E(K, m)$
1. Присвоить значение $t = h ⊕ t$
1. Вычислить значение $G = t ⊕ m$
1. $g(N, m, h) = G$

#### Функция $E(h,m)$

1. Вычислить значение **state** = $h \oplus m$
1. Для ```i= 0 по 11``` выполнить:
    - Присвоить значение $state = S(state)$
    - Присвоить значение $state = P(state)$
    - Присвоить значение $state = L(state)$
    - Вычислить $K=KeySchedule(h, i)$
    - Присвоить значение $state = state \oplus h$
1. Вернуть **state** в качестве результата.

#### KeySchedule(K, i)

Отвечает за формирование временного ключа ```K``` на каждом раунде функции $E(K, m)$

1. Присвоить значение $K = K \oplus C[i]$
1. Присвоить значение $K = S(K)$
1. Присвоить значение $K = P(K)$
1. Присвоить значение $K = L(K)$
1. Вернуть **K** в качестве результата функции.

С — это набор 512-битных значений


# Хэш-функция


![[Pasted image 20241009163138.png]]

1. **Первый этап**<br>инициализация всех нужных параметров
1. **Второй этап**<br> представляет собой так называемую итерационную конструкцию Меркла — Дамгорда с процедурой МД-усиления
1. **Третий этап**<br>завершающее преобразование: функция сжатия применяется к сумме всех блоков сообщения и дополнительно хешируется длина сообщения и его контрольная сумма

Общий алгоритм хэширования (любого сообщения ```M```):

1. Присвоить начальные значения внутренних переменных
    - Для хеш-функции с длиной выхода 512 бит: $h=iv=0x0064$. Для хеш-функции с длиной выхода 256 бит: $h=iv=0x0164$
    - $N = 0512$
    - $\Sigma = 0512$
2. Пока $\text{length}(M) \geq 512$
    - ```m``` — последние 512 бит сообщения ```M```
    - $h = g(N, m, h)$
    - $N = (N + 512) \text{mod} 2512$
    - $\Sigma = (\Sigma + m) \text{mod} 2512$
    - Обрезать M, убрав последние 512 бит
3. Произвести дополнение сообщения ```M``` до длины в 512 бит по следующему правилу: $m = 0511-|M|||1||M$, где |M| — длина сообщения M в битах
4. Вычислить $h = g(N, m, h)$
5. Вычислить $N = (N + |M|) \text{mod} 2512$
6. Вычислить $\Sigma = (\Sigma + m) \text{mod} 2512$
7. Вычислить $h = g(0, h, N)$
8. Вычислить $h = g(0, h, \Sigma)$
9. Возвращаем результат
    - Для хеш-функции с длиной выхода в 512 бит: ```h```
    - Для функции с длиной выхода 256 бит: ```MSB256(h)```