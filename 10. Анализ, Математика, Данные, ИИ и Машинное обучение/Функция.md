
### Функция одной переменной

**Функция одной переменной** (англ. function) — это такое *бинарное отношение* `R ⊆ X × Y`, что *каждому* элементу `x ∈ X` *соответствует единственный* элемент `y ∈ Y`. 

*Функцию именуют* *малыми латинскими буквами* (обычно `f`, `h`, `g`). 

*Элемент* `x ∈ X` называют **аргументом функции** `f` (англ. the argument of the function f), а *элемент* `y ∈ Y` - **значением** **функции** `f` (англ. the value of the function f). 

Говорят, что *функция* `f` *принимает аргумент* `x` и *возвращает значение* `y`.

<!--
Input, output
-->

*Обозначение функции* `f`, *принимающей аргумент* `x` и *возвращающей значение* `y`: **`f(x) = y`**. Так же *допустимы обозначение* **`y = f(x)`** и *сокращённые обозначения*: **`f(x)`**, **`f`**.

#### Функциональное бинарное отношение `R`
«*Пусть* `x ∈ X`, `y, z ∈ Y`, тогда *бинарное отношение* `R` называют **функциональным**, если *выполняется* **`(xRy ∧ xRz) → (y = z)`**, то есть, если *одновременно существуют связи* `xRy` и `xRz`, *не может существовать двух разных значений* `y` и `z` для *одного аргумента* `x` и тогда `y = z`.»

#### Отображение
*Функцию* `f(x) = y, x ∈ X, y ∈ Y` также называют **отображением множества `X` в множество `Y`** и *обозначают* **`f: X → Y`**.

Говорят, что *функция* `f` **отображает** *множество* `X` *в множество* `Y`.  
 

### Область определения и область значений функции

Множество `X` называют **областью определения** или **областью задания** **функции** `f` (англ. the domain of the function f) и *обозначают* **`D(f)`**.

Множество `Y` называют **областью значений функции** `f` (англ. the codomain of the function f).

*Множество таких* элементов `y ∈ Y`, *для которых существует упорядоченная пара* `(x, y) ∈ f`, `x ∈ X`, называют **множеством значений функции** `f` и *обозначают* **`E(f)`**.

Говорят, что **функция задана** (определена) **на множестве** `X` и **принимает значения из множества** `Y`. 

<!--
Таким образом, *функция* позволяет *по заданному* (переданному ей) аргументу `x` *однозначно определить* значение `y`.
-->

### Способы задания функции

### Непрерывная, разрывная и дискретная функции

В *математике* чаще всего рассматриваются *числовые функции*. 

**Числовая функция** - это *функция*, которая *ставит* одни *числа в соответствие* другим *числам*, то есть *принимает числовой аргумент* `x` и *возвращает числовое значение* `y`. 

Говоря простыми словами, **непрерывная функция** - это такая *функция*, у которой *между двумя любыми двумя значениями* `y1` и `y3` *всегда найдётся ещё одно значение* `y2` при *некотором аргументе* `x2`. Например, *между* значениями `y1 = 1` и `y3 = 2` *существует* значение `1.5`, между `1` и `1.5` - `1.25`, между `1` и `1.25` - `1.125` и так далее.

*Графически непрерывная функция* представляется *непрерывной линией*.

Понятно, что для *непрерывности функции необходимо*, чтобы *область значений* была *бесконечным множеством*, *иначе средняя точка* на каком-то этапе *не найдётся*.

Например, *линейная функция* `f(x) = 3x - 7, x ∈ R`, *графиком* которой является прямая*, *непрерывна*.

Например, функция, возвращающая *модуль числа*, *непрерывна*:
```
f(x) = |x| = {
  x, x >= 0;
 -x, x < 0;
}
```

Если *между некоторыми двумя значениями* `y1` и `y3` *не существует среднего значения* `y2`, то *функция* называется **разрывной функцией**, то есть *функцией*, *имеющей* **точки разрыва**. 

<!--
При наличии разрывов в функции появляются условия

Обозначение разрывной функции
-->


*Функция* может быть *разрывна в одной точке* и *непрерывна* во всех *остальных*. Например, функция `sgn(x): R → { -1, 0, 1 }`, *возвращающая знак числа*, *разрывна* лишь в *одной точке* `0`:
```
sgn(x) = {
  1, x > 0;
  0, x = 0;
 -1, x < 0;
}
```


Если *область значений* и *область определения функции* являются *конечными множеством*, то эта *функция* **разрывна во всех точках**. *Такую функцию* будем называть **дискретной функцией**.

*Непрерывные* и *разрывные в некоторых точках функции* изучаются в *курсе математического анализа*. Эти понятия затрагивают *бесконечные множества* и *далее* мы их *рассматривать не будем*, поскольку *дискретная математика* занимается лишь *дискретными объектами*.

<!--
*Пример числовой функции* `f`, *заданной* на *множестве чисел* из *промежутка* `[-1,1]` и *принимающей значения* из *множества действительных чисел* `R`: `f: [-1, 1] → R, f(x) = 4x - 1`. Если *передать* в функцию `f` *аргумент* `x = 0.5`, получим значение `y = f(0.5) = 3`.
-->

*Пример дискретной функции* `g`, *заданной* на *множестве* `{ 0, 1 }` и *принимающей значения* из множества `{ ложь, истина }`:  
```
g(x) = {
  ложь, x = 0;
  истина, x = 1;
}
```

<!--
В *первом примере* множества `[-1,1]` и `R` являются *бесконечными* (бесконечно много элементов), во *втором примере* множества `{ 0, 1 }` и `{ ложь, истина }` *конечны*.
-->

### Сюръективность, инъективность и биективность

Функция `f` называется **сюръективной** (*сюръекцией*), если *каждому элементу* `y ∈ Y` может быть *поставлен в соответствие хотя бы один* элемент `x ∈ X`. Иначе говоря, *не существует* таких `y ∈ Y`, которым *не соответствует хотя бы один* `x ∈ X`.

*Сюръективное отображение допускает существование двух разных* аргументов `x1, x2 ∈ X`, которым *соответствует* один и *тот же* `y ∈ Y` (`y = f(x1) = f(x2)`). Таким образом, если множество `X` *содержит больше элементов*, чем множество`Y`, то *отображение* всё ещё *может быть сюръективным*. Но если множество `Y` *содержит больше элементов*, чем множество `X`, то оно *не может быть сюръективным* по *определению функции*.

Функция `f` называется **инъективной** (*инъекцией*), если *любым двум разным* элементам `x1, x2 ∈ X` *соответствуют различные* элементы `y1, y2 ∈ Y` (если `x1 ≠ x2`, то `f(x1) ≠ f(x2)`). Другими словами, *для любых* элементов `x1, x2 ∈ X` *верно*: если *выполняется* `f(x1) = f(x2)`, то также *выполняется* и `x1 = x2`.

Функция `f` называется **биективной** (*биекцией*), если она *сюръективна* и *инъективна одновременно*.

Иначе говоря, **биекция** (*взаимно-однозначное отношение*) — такое *бинарное отношение* `R ⊆ X × Y`, что *каждому* значению `x ∈ X` *соответствует единственное* значение `y ∈ Y`, а *каждому* значению `y ∈ Y` *соответствует единственное* значение `x ∈ X`.

### Задача (сюръективность, инъективность, биективность)

<!--
За примерами далеко ходить не нужно :)
-->

«Даны функции `f, g: R → R; f(x) = x + 1; g(x) = |x|`. *Сюръективны*, *инъективны*, *биективны* ли они?»

Ответ: `f` *биективна*, `g` *не инъективна* и *не сюръективна*.

Значение `f(x)` *всегда на единицу больше* значения `x`, а множество действительных чисел `R` *бесконечно*, тогда:  
1) На `R` *для любого* значения `f(x)` *найдётся соответствующий* `x` - функция `f` *сюръективна*.
2) При `x1 ≠ x2` всегда будет выполняться `f(x1) ≠ f(x2)`, поскольку `x1 + 1 ≠ x2 + 1`, - функция `f` *инъективна*.

Тогда функция `f(x)` *биективна*.

*“Модуль”* всегда *возвращает только положительные значения* при любых аргументах, поэтому:
1) *Не существует* такого `x ∈ R`, чтобы `y ∈ R` *принял* какое-либо *отрицательное значение* из множества `R` - `g` *не сюръективна*.
2) Доказательство *от противного*. *Подберём* такой *пример*, чтобы *инъективность не соблюдалась*: `g(1) = |1| = 1 = |-1| = g(-1)`. Так как `1 ≠ -1`, а `g(1) = g(-1)`, - `g` *не инъективна*.

Итак, функция `g(x)` *не сюръективна*, *не инъективна*, а значит и *не биективна*.

### Функция нескольких переменных

Если *множество* `X` *представляет* собой *декартово произведение* `n` множеств `X = X1 × X2 × … × Xn`, то *отображение* `f: X → Y` называется **n-местным отображением** (*функцией n переменных*).

*Элементы* `x1 ∈ X1, x2 ∈ X2, …, xn ∈ Xn` *упорядоченного набора* `x = (x1, x2, … , xn)` называются **аргументами** *функции n переменных*.

В таком случае *запись* `y = f(x)` *эквивалентна* `y = f(x1, x2, … , xn)`. 

Пример *функции двух переменных*: `f: R × R → R, f(x,y) = x + y` - *числовая функция суммы двух значений*.

### Композиция функций

Для начала введём *аналогичное* определению *композиции бинарных отношений* определение *композиции функций*, *отличающееся лишь обозначниями*.

**Композицией** (суперпозицией) **функций** `f: X → Y` и `g: Y → Z` называется *такая функция* `(g ○ f): X → Z`, что *для любых* элементов `x ∈ X, z ∈ Z` *существует связь* `(g ○ f)(x) = z` *тогда и только тогда*, когда *существует* элемент `y ∈ Y` такой, что *одновременно существуют* связи `f(x) = y` и `g(y) = z`. 

Запись *композиции функций* `f` и `g` на *языке символов*: `∀x∈X,∀z∈Z: [(g ○ f)(x) = z] ⇔ ∃y∈Y: [f(x) = y]∧[g(y) = z]`.

Можно заметить, что *при композиции функций* `f` и `g` *результат* выполнения *функции* `f` *передаётся аргументом* в *функцию* `g`, то есть `g(f(x)) = z`. 

Тогда *определение упрощается*: *композицией* называется *функция* `(g ○ f): X → Z`, *определённая равенством*: `(g ○ f)(x) = g(f(x)), x ∈ X`. 

Запись `g ○ f` *читается* как «`g` *после* `f`».

Таким образом, с помощью *композиции сложные действия* можно *представлять* как *последовательность (цепочку) простых действий*.

*Композиция большего числа функций составляется аналогично*. Если *добавить* в неё ещё одну функцию `h: Z → P`, то `(h ○ g ○ f)(x) = h(g(f(x))), x ∈ X`.

Например, *составную функцию* `h(z) = 3z + 2` можно *представить* как *композицию* двух *простых функций* `f(x) = 3x` и `g(y) = y + 2`.

*Композиция* функций *некоммутативна*: `(g ○ f) ≠ (f ○ g)`. *Порядок следования функций имеет значение*: `f(g(x) ≠ g(f(x))`.

На *примере выше* несложно показать *некоммутативность композиции*: `f(g(1)) = 3 • (1 + 2) = 9`, `g(f(1)) = (3 • 1) + 2 = 5`.

*Композиция* функций *ассоциативна*: `h ○ g ○ f = (h ○ g) ○ f = h ○ (g ○ f)`.

*Композицию* интуитивно можно *использовать* и в *других областях*, если *рассматривать функцию* как *некоторое действие*. Например, *регистрация пользователя* может состоять из *композиции* следующих *действий* (функций): *проверки правильности ввода* данных, *проверки существования пользователя* в базе данных, *создания нового пользователя* в базе данных.

### Индикаторная функция

Пусть *имеется некоторое множество* `A` и *некоторое* его *подмножество* `B ⊆ A`.

**Индикаторной функцией** (англ. indicator function), **индикатором** или **характеристической функцией** (англ. characteristic function) **подмножества `B` множества `A`** называют *дискретную функцию*, *определенную* на множестве `A`, которая *указывает принадлежность элемента* `x ∈ A` к *подмножеству* `B` следующим образом:
1) *Функция возвращает значение* `1` для *аргумента* `x`, если *значение аргумента принадлежит* `B`.
2) *Функция возвращает значение* `0` для *аргумента* `x`, если *значение аргумента не принадлежит* `B`.

*Индикаторную функцию обозначают символами* `I`, `χ` или `1`.

*Формальное определение индикаторной функции*: `I: A → { 0, 1 }, B ⊆ A,`
```
I(x) = {
  1, x ∈ B;
  0, x ∉ B;
}
```

Если `B = A`, то `I(x) ≡ 1` (*индикаторная функция тождественно равна единице*, то есть её *значение равно* `1` для *любого аргумента* `x`). Если  `B = ∅`, то `I(x) ≡ 0` (*индикаторная функция тождественно равна нулю*).

Например, если `A = { 3, 1, 7 }`, `B = { 1, 7 }` то `I(3) = 0`, `I(1) = I(7) = 1`.

