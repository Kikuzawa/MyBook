## Ключи
- [Об идентификации](#об-идентификации)
- [Потенциальный ключ](#потенциальный-ключ)
- [Первичный ключ](#первичный-ключ)
- [Простые и составные ключи](#простые-и-составные-ключи)
- [Значение ключа](#значение-ключа)
- [Естественный ключ](#естественный-ключ)
- [Суррогатный ключ](#суррогатный-ключ)
- [Внешний ключ](#внешний-ключ)

### Об идентификации

**Идентификатор**, **ID** (англ. identifier — опознаватель) — это *уникальный признак объекта*.

*Идентификаторы* позволяют **идентифицировать объект**, то есть *выделить* (*найти*) его *среди других объектов*. 

Например, можно по *номеру паспорта определить* (*идентифицировать*) *человека*, по *IP-адресу* - *физический компьютер*, по *координатам* - *точку* на карте, по *шрих-коду* - *товар* в магазине, по *QR-коду* - *ссылку*, по *ссылке* - *сайт* и так далее.

Для *идентификации кортежей отношения* используются *ключи*.

### Потенциальный ключ

Как мы уже знаем, *каждый кортеж отношения уникален*. Поэтому *при необходимости найти конкретный кортеж* операцией *выборки*, *достаточно перечислить все значения* его *атрибутов*, но обычно *так не делают*.

Пусть *имеется отношение* `R`, содержащее в заголовке `n` *атрибутов*.

**Потенциальным ключом** (англ. candidate key) называют *подмножество из* `m <= n` *атрибутов отношения* `R`, которое *удовлетворяет условиям* **уникальности** и **минимальности**. 

**Условие уникальности** *требует*, чтобы *в отношении* `R` *не могло существовать двух кортежей*, содержащих *одни и те же значения тех атрибутов*, *из которых состоит потенциальный ключ*.

Важно отметить, что `R` именно *“не может содержать двух кортежей”*, а не *“не содержит двух кортежей”*. Например, если в *компании* работает *несколько сотрудников* и *все имеют различный цвет глаз*, это *не означает*, что *цвет глаз* является *уникальным идентификатором*: всегда *может появиться новый сотрудник* с *уже существующим цветом глаз* и *идентификация станет невозможной*. 

Таким образом, *уникальность опирается не на наличие объекта* в *текущий момент времени*, а на *особенности (природу) класса объектов*, которые *допускают возможность появления нового объекта* в *любой момент времени*. *Неплохими идентификаторами сотрудника компании* могут стать: *серия и номер паспорта*, *номер трудовой книги*, *рабочий email* или *номер телефона* (все они *не могут повториться у двух сотрудников*).
 
**Условие минимальности** (*несократимости*) *требует*, чтобы *среди атрибутов потенциального ключа отсутствало меньшее подмножество* из `k <= m` *атрибутов*, которое *удовлетворяет условию уникальности*. 

Другими словами, *при исключении любых атрибутов* из *потенциального ключа условие уникальности* должно *перестать выполняться*.



В отношении *всегда существует хотя бы один потенциальный ключ* (*множество всех значений атрибутов* кортежа), поскольку *все кортежи отношения уникальны* по определению.

В отношении может *одновременно существовать несколько потенциальных ключей*.

На *примере ниже* представлено *отношение* с *двумя потенциальным ключами*, *каждый* из которых *состоит* из *одного элемента*: `{ Номер телефона }` и `{ Email }`.

#### Отношение `R` (пользователи)
Имя | Фамилия | Номер телефона | Email
:--: | :--: | :--: | :--:
Джон | Дрим | 8768 | johndream@example
Фрэнк | Старк | 1442 | frankstark@example
Ален | Стоун | 3567 | alenstone@example

### Первичный ключ

Как уже отмечалось ранее, *отношение может содержать несколько потенциальных ключей*, *по каждому* из которых *можно идентифицировать объект*. *Один* из этих ключей *выбирается* в качестве *основного* и называется **первичным ключом** (англ. primary key) **отношения**, *оставшиеся потенциальные ключи* называют **альтернативными ключами отношения**.

Если *в отношении содержится только один потенциальный ключ*, то он и *является первичным ключом* данного отношения.

Если *в отношении содержится несколько потенциальных ключей*, то имеется *два основных критерия выбора первичного ключа*:
1) **Удобство использования**. Чаще всего *выбирается потенциальный ключ* с *наименьшим физическим размером* (*занимает меньше памяти* на *компьютере*) или *содержит наменьшее количество атрибутов*. 
2) **Сохранение уникальности с течением времени**. Некоторые *идентификаторы могут утрачивать* свою *уникальность* со *временем*.

### Простые и составные ключи

*Первичный ключ*, *состоящий* из *одного атрибута*, называют **простым ключом**, а *состоящий* из *нескольких атрибутов* - **составным ключом**.

*Чаще всего* используются *простые ключи* (`id`, `number`, `username`, `email`, `phone`), поскольку их *проще хранить*, с ними *проще работать*. 

*Редко*, но бывают случаи, когда *удобнее* использовать *составной ключ* или *нет возможности* использовать *простой ключ*.

Рассмотрим пример *составного ключа*, *разбив телефонный номер* на *группы*. В *системе*, *работающей* с *телефонными номерами*, *разбиение номера* могло бы *оптимизировать поиск* и *фильтрацию*. Из чего *состоит телефонный номер*? *Его схема различна* в *разных странах*. Например, *американский номер состоит* из *кода страны*, *кода региона*, *кода телефонного узла* и *абонентского номера*: `+1 (234) 235 1779`. 

#### Отношение `R`
Код региона | Код узла | Абонентский номер | Фамилия владельца
:--: | :--: | :--: | :--:
234 | 145 | 1984 | Ирвинг
234 | 310 | 7817 | Купер
235 | 420 | 6168 | Редли

Тогда *первичный ключ* `PK` отношения `R` имеет вид:
```
{
  (Код региона, integer),
  (Код узла, integer),
  (Абонентский номер, integer)
}
```

*Исключение любых атрибутов* из *ключа* `PK` *приведёт* к *утрате уникальности* этого *ключа*.



Другие *примеры составных ключей*: *серия* и *номер паспорта* (не уникальны по-отдельности), *масть* и *число* на *игровой карте*, *номер ряда* и *номер места* в *кинотеатре*, *составные части URL*, *составные части адреса электронной почты* и так далее.



<!--
Идентификаторы могут со временем меняться: меняются паспорт, номер телефона, email и даже отпечаток пальца, поэтому часто в качестве идентификатора используют случайно сгенерированный хэш.
-->



### Значение ключа

**Значением ключа** называют *кортеж*, *состоящий* из *значений атрибутов* этого *ключа*.

#### Отношение `R` (места в кинозале)
Номер ряда | Номер места | Место для влюблённых | VIP |
:--: | :--: | :--: | :--:
7 | 18 | true | false
7 | 19 | true | false
3 | 22 | false | false
10 | 3 | false | true

Тогда *первичный ключ* `PK` *отношения* `R` имеет вид:
```
{
  (Номер ряда, integer),
  (Номер места, integer)
}
```
*Кортеж* `((Номер ряда, 7), (Номер места, 18))` - *одно* из доступных *значений ключа* `PK`.

### Естественный ключ


*Разделим понятия реального объекта* (дом, машина, человек, дерево) и его *физического представления* в некоторой *базе данных* (например, *набор значений атрибутов*).


**Естественный ключ** (англ. natural key, business key, domain key) - это *уникальный ключ*, который *идентифицирует* некоторый *реальный объект*, при этом *полностью зависит* от *свойств* (*природы*) этого *объекта* и *не зависит* от его *физического представления* (реализации) в *конкретной базе данных*.

*Естественный ключ* *подбирается* на основе *реальных наблюдений за объектом*, поэтому его *уникальность опирается исключительно* на *уникальные черты реального объекта*.

В рамках *реляционной модели данных природа объекта описывается* с помощью *атрибутов*, а поскольку *потенциальный ключ* напрямую *зависит* от них, он и *является естественным ключом*.

Как и в случае с *потенциальным ключами*, *естественных ключей* у *отношения* может быть *несколько*.

*Примеры* *естественных ключей* всё *те же*, что и *примеры* *потенциальных ключей*: *человека* можно *идентифицировать* по *серии* и *номеру паспорта*, *пользователя* - по *email*, *дом* - по *адресу* и так далее. *Всё* это - *натуральные ключи*, *взятые* из *предметных областей* (*доменов*) соответствующих *объектов*.

*Естественные ключи* *являются полноценной частью приложения* и *не скрываются от глаз пользователя* (например, на *сайтах* можно часто *видеть email* или *номер телефона*).

### Суррогатный ключ

**Суррогатный ключ** (англ. surrogate key, pseudokey, synthetic key) - это *уникальный идентификатор* как для *реального объекта*, так и для его *физического представления* в *базе данных*.

В *отличии* от *естественного ключа*, *суррогатный ключ никак не зависит* от *свойств* *реального объекта*, а следовательно *и от атрибутов*. *Суррогатный ключ генерируется системой* по *заданному алгоритму*, поэтому *не имеет смысла вне системы*.

Чаще всего *суррогатный ключ представляет собой* некоторый *хэш* (*произвольно сгенерированная строка*) или *целочисленное число*.

Самые распространённые *способы генерации суррогатного ключа*:  
1) **Universally Unique Identifier** (*UUID*). *Пример*: `9fc2e9ad-fae7-4f25-ae48-3f45284f2299`.
2) **Globally Unique Identifier** (*GUID*). *Пример*: `75f067fa-b95f-405c-a1bd-29164461a65f`.
3) **Object Identifier** (*ObjectID*). *Пример*: `ObjectId("507f1f77bcf86cd899439017")`.
4) `AUTO_INCREMENT` (MySQL), `AUTOINCREMENT` (SQLite) `SEQUENCE` (SQL Server, Oracle).

*Суррогатные ключи* относятся к *внутренней логике* (внутренней реализации) *приложения*. Они *не несут* в себе никакой *полезной информации* для *пользователя* и поэтому *скрыты от его глаз*.


У *отношения* может быть *несколько суррогатных ключей*.


*Преимущества использования суррогатных ключей*:  
1) **Неизменность** (*стабильность*). Благодаря *независимости суррогатного ключа* от *атрибутов объекта*, *ключ остаётся неизменным* при *изменении* этого *объекта*.  
2) **Компактность**. *Суррогатный ключ* всегда *состоит* только из *одного значения*, *размер* которого *фиксирован* и обычно *невелик* (*размер ключа зависит* от *алгоритма генерации*, который *можно выбирать*), что *уменьшает расход памяти* и *увеличивает скорость поиска объектов по ключу*.
3) **Единообразие**. Если *все ключи* в *системе создаются* по *одному алгоритму* (например, *везде* используется *UUID*), то *логика обработки данных упрощается* и *становится предсказуемой* для *разработчика* в *любом месте системы*.
4) **Уникальность ключа во всей системе** - *не только* в отдельном *отношении*.

Основным *недостатком суррогатного ключа* является то, что он *не связан* с самим *объектом по смыслу*: по *такому ключу нельзя судить* как о *содержимом объекта*, так и о *классе*, которому *этот объект принадлежит*.  




### Внешний ключ



<!--
Говоря простыми словами, *внешний ключ* - это *подмножество атрибутов* некоторого *отношения* `S`, *значения* которых *совпадают* со *значениями атрибутов потенциального ключа* другого *отношения* `R`. 
-->

*Внешние ключи подобны ссылкам* на *объекты*. *Внешний ключ* позволяет в *кортеже одного отношения сослаться* на *кортеж другого отношения*, поскольку *хранит* *значение* *потенциального ключа* этого отношения. 

*Использование внешних ключей лишает* нас *необходимости в дублировании данных*. На эти *данные можно* просто *сослаться* из *другого места*. Такой подход

<!--
*Связи* позволяют *хранить данные* в *нормализованном виде* (без дублирования).
(внешние ключи)
-->

Пусть *имеются отношения* `R` и `S` (*не обязательно различные*). **Внешним ключом** (англ. foreign key) `FK` называют *такое подмножество атрибутов* отношения `S`, для которого *выполняются условия*:
1) Отношение `R` *имеет такой потенциальный ключ* `CK`, что *у ключей* `CK` и `FK` *совпадают количество атрибутов* и их *типы данных* (*при переименовании атрибутов ключи совпадают*).
2) *Каждое значение* внешнего ключа `FK` в *некотором кортеже* отношения `S` *совпадает* со *значением* потенциального включа `CK` в *некотором кортеже* отношения `R`. Иначе говоря, *множество значений* ключа `FK` *содержится* (является *подмножеством*) в *множестве значений* ключа `CK`.

*Обозначение внешнего ключа* `FK`, *ссылающегося* на *потенциальный ключ* `CK`: `FK → CK`.


*Отношение* `R`, *содержащее потенциальный ключ* `CK`, называют **главным** (*родительским*) **отношением**, *отношение* `S`, *содержащее внешний ключ* `FK`, называют **подчинённым** (*дочерним*) **отношением**.

*Ниже* представлен *пример* простенькой реализации *чата*. *Родительское отношение* `R` имеет *потенциальный ключ* `ID`, *дочернее отношение* `S` имеет *два внешних ключа*: `SENDER_ID → ID` (*идентификатор отправителя*) и `RECIPIENT_ID → ID` (*идентификатор получателя*).


#### Отношение `R` (пользователи)
ID | Имя пользователя
:--: | :--:
cde | Сара
fkh | Рози

#### Отношение `S` (сообщения)
ID | Текст | SENDER_ID | RECIPIENT_ID
:--: | :--: | :--: | :--:
erksh | Доброй ночи | cde | fkh
jhtbe | И тебе | fkh | cde

