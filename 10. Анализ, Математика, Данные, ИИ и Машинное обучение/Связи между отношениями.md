## Связи между отношениями
- [О связях между отношениями](#о-связях-между-отношениями)
- [Один к одному (1:1)](#один-к-одному-11)
- [Один ко многим (1:M)](#один-ко-многим-1m)
- [Многие к одному (M:1)](#многие-к-одному-m1)
- [Многие ко многим (M:M)](#многие-ко-многим-mm)
- [Ссылочная целостность](#ссылочная-целостность)

### О связях между отношениями

*Связи между отношениями похожи* по *смыслу* на *бинарные отношения из теории множеств*. *Связи передают* то, как *объекты соотносятся* (связаны) *друг с другом*. В *терминах реляционной модели данных*: *связь устаналивает соотношение* (соответствие) *между кортежами двух отношений*, причём *не обязательно различных*.

*Связи между* двумя *отношениями устанавливаеются* при помощи *внешних ключей*.


Как уже *ранее* отмечалось, *отношение*, *содержащее внешний ключ* `FK → CK`, называют **дочерним**, а *отношение*, *содержащее потенциальный ключ* `CK`, называют **родительским**.

*Между родительским* и *дочерним отношениями* существует *4 вида связей*:
- [Один к одному (1:1)](#один-к-одному-11)
- [Один ко многим (1:M)](#один-ко-многим-1m)
- [Многие к одному (M:1)](#многие-к-одному-m1)
- [Многие ко многим (M:M)](#многие-ко-многим-mm)

### Один к одному (1:1)

**Один к одному** `1:1` (англ. one-to-one) - такая *связь между отношениями `R` и `S`*, при которой *каждому кортежу* отношения `R` *соответствует только один* (или *ни одного*) *кортеж* отношения `S` и *каждому кортежу* отношения `S` *соответствует только один* (или *ни одного*) *кортеж* отношения `R`. Другими словами, *отношение* `R` *имеет потенциальный ключ* `R.CK` и *внешний ключ* `R.FK → S.CK`, а *отношение* `S` *имеет потенциальный ключ* `S.CK` и *внешний ключ* `S.FK → R.CK`.

Пример *связи* `1:1`: *одно королевство* - *один король* (королева). 

*Отношение* `R`, представленное *таблицей* ниже, содержит *потенциальный ключ* `R.ID` и *внешний ключ* `R.KINGDOM_ID → S.ID`, *отношение* `S` содержит *потенциальный ключ* `S.ID` и *внешний ключ* `S.KING_ID → R.ID`.


#### Отношение `R` (современные короли и королевы)
ID | Имя | KINGDOM_ID
:--: | :--: | :--:
val | Виллем-Александр | NL
el2 | Елизавета II | GB
k16 | Карл XVI Густав | SE
ma2 | Маргрета II | DK
fil | Филипп | BE
fi6 | Филипп VI | ES
ha5 | Харальд V | NO

#### Отношение `S` (страны)
ID | Название | KING_ID
:--: | :--: | :--:
BE | Бельгия | fil
GB | Великобритания | el2
DK | Дания | ma2
ES | Испания | fi6
NL | Нидерланды | val
NO | Норвегия | ha5
SE | Швеция | k16

<!--
Страна и столица
-->


### Один ко многим (1:M)


<!--
Определение через подмножество
-->

**Один ко многим** `1:M` (англ. one-to-many) - такая *связь между отношениями `R` и `S`*, при которой *каждому кортежу* отношения `R` *соответствует несколько* (или *ни одного*) *кортежей* отношения `S` и *каждому кортежу* отношения `S` *соответствует не более одного кортежа* отношения `R`. Другими словами, *отношение* `R` *имеет потенциальный ключ* `R.CK`, а *отношение* `S` *имеет внешний ключ* `S.FK → R.CK`.

<!--

В одном диалоге много сообщений, один автор может написать несколько книг.

В одной стране много городов (штатов).

Одна страна охватывает несколько часовых и климатических поясов

-->

Рассмотрим интересный *пример связи* `1:M`: *один отец* может иметь *нескольких детей*, но *каждый ребёнок* имеет *лишь одного биологического отца*. 

Как уже *ранее отмечалось*, *отношения* `R` и `S` *не обязательно различны* (они *могут представлять* собой *одно и то же* отношение). *Отношение* `R`, представленное *таблицей* ниже, содержит *потенциальный ключ* `R.ID` и *внешний ключ* `R.PARENT_ID → R.ID`.

#### Отношение `R` (отцы и дети)
ID | Имя | Возраст | PARENT_ID
:--: | :--: | :--: | :--:
P1 | Джон | 65 | NULL
P2 | Джим | 43 | P1
P3 | Джек | 20 | P2
P4 | Джоан | 22 | P2

### Многие к одному (M:1)

**Многие к одному** `M:1` (англ. many-to-one) - *зеркальное отражение связи* `1:M` (в *определении достаточно поменять местами отношения* `R` и `S`).


Пример *связи* `M:1`: *много городов* может *принадлежать* *одной стране*, но *один город не может принадлежать двум странам одновременно*.

*Отношение* `R`, представленное *таблицей* ниже, имеет *потенциальный ключ* `R.ID` и *внешний ключ* `R.COUNTRY_ID → S.ID`, а *отношение* `S` *содержит только потенциальный ключ* `S.ID`.

#### Отношение `R` (города)
ID | Имя | COUNTRY_ID
:--: | :--: | :--:
kiev | Киев | UA
lviv | Львов | UA
sydney | Сидней | AU

#### Отношение `S` (страны)
ID | Название
:--: | :--:
UA | Украина
AU | Австралия

<!--
Поменять пример с примером выше местами
-->


### Многие ко многим (M:M)

**Многие ко многим** `M:M` (англ. many-to-many) - такая *связь между отношениями `R` и `S`*, при которой *каждому кортежу* отношения `R` *соответствует несколько* (или *ни одного*) *кортежей* отношения `S` и *каждому кортежу* отношения `S` *соответствует несколько* (или *ни одного*) *кортежей* отношения `R`. С *помощью двух отношений* такую связь на практике *реализовать нельзя*. 

Другими словами, *отношение* `R` *имеет потенциальный ключ* `R.CK`, *отношение* `S` *имеет потенциальный ключ* `S.CK` и *существует* такое *отношение* `T`, *тело* которого *состоит* из *кортежей* `(T.FK1 → S.CK, T.FK2 → R.CK)`, содержащих *внешние ключи*, *ссылающиеся* на *потенциальные ключи отношений* `R` и `S`. *Отношение* `T` имеет *связь* `M:1` (многие к одному) с *каждым из отношений* `R` и `S`.


Пример *связи* `M:M`: *каждый сотрудник* компании может знать *несколько разговорных языков*, *несколько сотрудников* могут говорить на *одном языке*.

### Отношение `R` (разговорные языки)
ID | Язык
:--: | :--:
en | Анлийский
ru | Русский
fr | Французский

### Отношение `S` (сотрудники)
ID | Имя | Должность
:--: | :--: | :--:
sara1 | Сара | программист
dina7 | Дина | дизайнер

Пусть *Сара* знает *английский* и *французский*, а *Дина* - *английский* и *русский*, тогда:

### Отношение `T` (соответствие между языками и сотрудниками)
ID | WORKER_ID | LANGUAGE_ID
:--: | :--: | :--:
t1 | sara1 | en
t1 | sara1 | fr
t2 | dina7 | en
t2 | dina7 | ru

В *таблице выше* можно увидеть, что *отношение* `T` имеет *внешний ключ* `T.LANGUAGE_ID → R.ID` (*связь* `M:1` между `T` и `R`) и *внешний ключ* `T.WORKER_ID → S.ID` (*связь* `M:1` между `T` и `S`).


Ещё один пример *связи* `M:M`: у *научной статьи* может быть *несколько авторов*, у *автора* может быть *много научных статей*.


### Ссылочная целостность

*Первичные ключи могут изменяться*. Простой пример: *пользователь* хочет *сменить email* или *номер телефона*. Если *существует связь*, *использующая* подобный *потенциальный ключ* `CK`, то *ссылающейся* на него *внешний ключ* `FK → CK` так же *должен измениться*.

**Ссылочной целостностью** (англ. referential integrity) называют *корректность значений всех внешних ключей*, то есть *хранение* *актуального значения потенциального ключа* `CK` в *каждом внешнем ключе* `FK → CK`.

Чтобы *обеспечить ссылочную целостность*, необходимо при *изменении значения потенциального ключа* `CK` *заменить значения всех ссылающихся* на него *внешних ключей* `FK` или *отменить операцию изменения*, если *замена невозможна*. 

В некоторых *системах управления базами данных* *ссылочная целостность поддерживается автоматически*.

